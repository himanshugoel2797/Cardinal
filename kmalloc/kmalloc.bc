; ModuleID = 'kmalloc/kmalloc.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.kmalloc_info = type { i64, i64, %struct.kmalloc_info* }
%struct.MemoryAllocationsMap = type { i32, i64, i64, i64, i32, i32, i64, i64, %struct.MemoryAllocationsMap* }

@max_allocs = global i32 0, align 4
@free_space = global i32 0, align 4
@allocation_info = global %struct.kmalloc_info* null, align 8
@next_free_block = global %struct.kmalloc_info* null, align 8
@alloc_sync = common global i64* null, align 8
@k_pages_base_addr = common global i8* null, align 8
@retry = global i8 0, align 1

; Function Attrs: noredzone nounwind uwtable
define void @kmalloc_init(%struct.MemoryAllocationsMap* nocapture %allocationMap) #0 {
  %virtBaseAddr_base = alloca i64, align 8
  %1 = tail call i64* @CreateBootstrapSpinlock() #3
  store i64* %1, i64** @alloc_sync, align 8, !tbaa !1
  %2 = bitcast i64* %virtBaseAddr_base to i8*
  call void @llvm.lifetime.start(i64 8, i8* %2) #2
  store i64 0, i64* %virtBaseAddr_base, align 8, !tbaa !5
  %3 = tail call i64 @GetActiveVirtualMemoryInstance() #3
  %4 = call i32 @FindFreeVirtualAddress(i64 %3, i64* nonnull %virtBaseAddr_base, i64 16777216, i32 0, i32 4) #3
  %5 = call i64 @AllocatePhysicalPageCont(i32 4096) #3
  %6 = call i64 @GetActiveVirtualMemoryInstance() #3
  %7 = load i64, i64* %virtBaseAddr_base, align 8, !tbaa !5
  %8 = call i32 @MapPage(i64 %6, %struct.MemoryAllocationsMap* null, i64 %5, i64 %7, i64 16777216, i32 0, i32 0, i32 4) #3
  %9 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %allocationMap, i64 0, i32 0
  store i32 0, i32* %9, align 4, !tbaa !7
  %10 = load i64, i64* %virtBaseAddr_base, align 8, !tbaa !5
  %11 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %allocationMap, i64 0, i32 1
  store i64 %10, i64* %11, align 8, !tbaa !9
  %12 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %allocationMap, i64 0, i32 3
  store i64 0, i64* %12, align 8, !tbaa !10
  %13 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %allocationMap, i64 0, i32 5
  store i32 0, i32* %13, align 4, !tbaa !11
  %14 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %allocationMap, i64 0, i32 6
  store i64 0, i64* %14, align 8, !tbaa !12
  %15 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %allocationMap, i64 0, i32 7
  store i64 0, i64* %15, align 8, !tbaa !13
  store i64 %10, i64* bitcast (%struct.kmalloc_info** @allocation_info to i64*), align 8, !tbaa !1
  store i64 %10, i64* bitcast (%struct.kmalloc_info** @next_free_block to i64*), align 8, !tbaa !1
  %16 = add i64 %10, 1048576
  %17 = inttoptr i64 %16 to i8*
  store i8* %17, i8** @k_pages_base_addr, align 8, !tbaa !1
  store i32 43690, i32* @max_allocs, align 4, !tbaa !14
  store i32 15728640, i32* @free_space, align 4, !tbaa !14
  %18 = inttoptr i64 %10 to i8*
  %19 = call i8* @memset(i8* %18, i32 0, i64 1048576) #3
  %20 = load i64, i64* bitcast (i8** @k_pages_base_addr to i64*), align 8, !tbaa !1
  %21 = load %struct.kmalloc_info*, %struct.kmalloc_info** @allocation_info, align 8, !tbaa !1
  %22 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %21, i64 0, i32 0
  store i64 %20, i64* %22, align 8, !tbaa !16
  %23 = load i32, i32* @free_space, align 4, !tbaa !14
  %24 = zext i32 %23 to i64
  %25 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %21, i64 0, i32 1
  store i64 %24, i64* %25, align 8, !tbaa !18
  %26 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %21, i64 0, i32 2
  store %struct.kmalloc_info* null, %struct.kmalloc_info** %26, align 8, !tbaa !19
  %27 = load %struct.kmalloc_info*, %struct.kmalloc_info** @allocation_info, align 8, !tbaa !1
  %28 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %27, i64 0, i32 0
  %29 = load i64, i64* %28, align 8, !tbaa !16
  %30 = and i64 %29, -2
  store i64 %30, i64* %28, align 8, !tbaa !16
  %31 = load %struct.kmalloc_info*, %struct.kmalloc_info** @next_free_block, align 8, !tbaa !1
  %32 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %31, i64 1
  store %struct.kmalloc_info* %32, %struct.kmalloc_info** @next_free_block, align 8, !tbaa !1
  call void @llvm.lifetime.end(i64 8, i8* %2) #2
  ret void
}

; Function Attrs: noredzone
declare i64* @CreateBootstrapSpinlock() #1

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #2

; Function Attrs: noredzone
declare i32 @FindFreeVirtualAddress(i64, i64*, i64, i32, i32) #1

; Function Attrs: noredzone
declare i64 @GetActiveVirtualMemoryInstance() #1

; Function Attrs: noredzone
declare i64 @AllocatePhysicalPageCont(i32) #1

; Function Attrs: noredzone
declare i32 @MapPage(i64, %struct.MemoryAllocationsMap*, i64, i64, i64, i32, i32, i32) #1

; Function Attrs: noredzone
declare i8* @memset(i8*, i32, i64) #1

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #2

; Function Attrs: noredzone nounwind uwtable
define void @kcompact() #0 {
  %1 = load %struct.kmalloc_info*, %struct.kmalloc_info** @allocation_info, align 8, !tbaa !1
  %2 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %1, i64 0, i32 2
  %3 = load %struct.kmalloc_info*, %struct.kmalloc_info** %2, align 8, !tbaa !19
  %4 = icmp eq %struct.kmalloc_info* %3, null
  br i1 %4, label %.thread._crit_edge, label %.preheader.preheader

.preheader.preheader:                             ; preds = %0
  br label %.preheader

.preheader:                                       ; preds = %.preheader.backedge, %.preheader.preheader
  %a_info.1 = phi %struct.kmalloc_info* [ %1, %.preheader.preheader ], [ %a_info.1.be, %.preheader.backedge ]
  %5 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.1, i64 0, i32 2
  %6 = load %struct.kmalloc_info*, %struct.kmalloc_info** %5, align 8, !tbaa !19
  %7 = icmp eq %struct.kmalloc_info* %6, null
  br i1 %7, label %.thread.backedge, label %8

; <label>:8                                       ; preds = %.preheader
  %9 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.1, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !16
  %11 = and i64 %10, 1
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %13, label %.preheader.backedge

.preheader.backedge:                              ; preds = %8, %.thread.backedge
  %a_info.1.be = phi %struct.kmalloc_info* [ %6, %8 ], [ %a_info.0.be, %.thread.backedge ]
  br label %.preheader

; <label>:13                                      ; preds = %8
  %14 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %6, i64 0, i32 1
  %15 = load i64, i64* %14, align 8, !tbaa !18
  %16 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.1, i64 0, i32 1
  %17 = load i64, i64* %16, align 8, !tbaa !18
  %18 = add i64 %17, %15
  store i64 %18, i64* %16, align 8, !tbaa !18
  %19 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %6, i64 0, i32 2
  %20 = load %struct.kmalloc_info*, %struct.kmalloc_info** %19, align 8, !tbaa !19
  store %struct.kmalloc_info* %20, %struct.kmalloc_info** %5, align 8, !tbaa !19
  br label %.thread.backedge

.thread.backedge:                                 ; preds = %.preheader, %13
  %a_info.0.be = phi %struct.kmalloc_info* [ %20, %13 ], [ %a_info.1, %.preheader ]
  %21 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0.be, i64 0, i32 2
  %22 = load %struct.kmalloc_info*, %struct.kmalloc_info** %21, align 8, !tbaa !19
  %23 = icmp eq %struct.kmalloc_info* %22, null
  br i1 %23, label %.thread._crit_edge.loopexit, label %.preheader.backedge

.thread._crit_edge.loopexit:                      ; preds = %.thread.backedge
  br label %.thread._crit_edge

.thread._crit_edge:                               ; preds = %.thread._crit_edge.loopexit, %0
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i8* @kmalloc(i64 %size) #0 {
  %1 = load i64*, i64** @alloc_sync, align 8, !tbaa !1
  %2 = tail call zeroext i8 @LockSpinlock(i64* %1) #3
  %3 = add i64 %size, 48
  %a_info.0.1 = load %struct.kmalloc_info*, %struct.kmalloc_info** @allocation_info, align 8
  %4 = icmp eq %struct.kmalloc_info* %a_info.0.1, null
  br i1 %4, label %.critedge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %0
  %5 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0.1, i64 0, i32 2
  %6 = load %struct.kmalloc_info*, %struct.kmalloc_info** %5, align 8, !tbaa !19
  %7 = icmp eq %struct.kmalloc_info* %6, null
  br i1 %7, label %.critedge, label %.lr.ph11.preheader

.lr.ph11.preheader:                               ; preds = %.lr.ph.preheader
  br label %.lr.ph11

.lr.ph11:                                         ; preds = %.lr.ph11.preheader, %.lr.ph.backedge
  %8 = phi %struct.kmalloc_info* [ %18, %.lr.ph.backedge ], [ %6, %.lr.ph11.preheader ]
  %a_info.0210 = phi %struct.kmalloc_info* [ %8, %.lr.ph.backedge ], [ %a_info.0.1, %.lr.ph11.preheader ]
  %9 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0210, i64 0, i32 0
  %10 = load i64, i64* %9, align 8, !tbaa !16
  %11 = and i64 %10, 1
  %12 = icmp eq i64 %11, 0
  br i1 %12, label %13, label %.lr.ph.backedge

; <label>:13                                      ; preds = %.lr.ph11
  %14 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0210, i64 0, i32 1
  %15 = load i64, i64* %14, align 8, !tbaa !18
  %16 = icmp ult i64 %15, %3
  br i1 %16, label %.lr.ph.backedge, label %.critedge.loopexit

.lr.ph.backedge:                                  ; preds = %13, %.lr.ph11
  %17 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %8, i64 0, i32 2
  %18 = load %struct.kmalloc_info*, %struct.kmalloc_info** %17, align 8, !tbaa !19
  %19 = icmp eq %struct.kmalloc_info* %18, null
  br i1 %19, label %.critedge.loopexit, label %.lr.ph11

.critedge.loopexit:                               ; preds = %.lr.ph.backedge, %13
  %a_info.0.lcssa.ph = phi %struct.kmalloc_info* [ %8, %.lr.ph.backedge ], [ %a_info.0210, %13 ]
  br label %.critedge

.critedge:                                        ; preds = %.critedge.loopexit, %.lr.ph.preheader, %0
  %a_info.0.lcssa = phi %struct.kmalloc_info* [ null, %0 ], [ %a_info.0.1, %.lr.ph.preheader ], [ %a_info.0.lcssa.ph, %.critedge.loopexit ]
  %20 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0.lcssa, i64 0, i32 0
  %21 = load i64, i64* %20, align 8, !tbaa !16
  %.tr = trunc i64 %21 to i32
  %22 = and i32 %.tr, 1
  %23 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0.lcssa, i64 0, i32 1
  %24 = load i64, i64* %23, align 8, !tbaa !18
  %25 = icmp ult i64 %24, %3
  %26 = zext i1 %25 to i32
  %27 = or i32 %26, %22
  %28 = icmp eq i32 %27, 0
  br i1 %28, label %48, label %29

; <label>:29                                      ; preds = %.critedge
  %30 = load i64*, i64** @alloc_sync, align 8, !tbaa !1
  %31 = tail call zeroext i8 @UnlockSpinlock(i64* %30) #3
  %32 = load i8, i8* @retry, align 1, !tbaa !20
  %33 = icmp eq i8 %32, 0
  br i1 %33, label %34, label %86

; <label>:34                                      ; preds = %29
  store i8 1, i8* @retry, align 1, !tbaa !20
  %35 = tail call i8* @kmalloc(i64 %3) #4
  store i8 0, i8* @retry, align 1, !tbaa !20
  %36 = bitcast i8* %35 to i64*
  store i64 -2401053089206453570, i64* %36, align 8, !tbaa !5
  %37 = getelementptr inbounds i8, i8* %35, i64 8
  %38 = bitcast i8* %37 to i64*
  store i64 %size, i64* %38, align 8, !tbaa !5
  %39 = getelementptr inbounds i8, i8* %35, i64 16
  %40 = bitcast i8* %39 to i64*
  store i64 -2401053089206453570, i64* %40, align 8, !tbaa !5
  %41 = ptrtoint i8* %35 to i64
  %42 = add i64 %41, 24
  %43 = add i64 %42, %size
  %44 = inttoptr i64 %43 to i64*
  store i64 -2401050963649814811, i64* %44, align 8, !tbaa !5
  %45 = getelementptr inbounds i64, i64* %44, i64 1
  store i64 %size, i64* %45, align 8, !tbaa !5
  %46 = getelementptr inbounds i64, i64* %44, i64 2
  store i64 -2401050963649814811, i64* %46, align 8, !tbaa !5
  %47 = inttoptr i64 %42 to i8*
  ret i8* %47

; <label>:48                                      ; preds = %.critedge
  %49 = and i64 %21, -2
  %50 = icmp eq i64 %24, %3
  br i1 %50, label %69, label %51

; <label>:51                                      ; preds = %48
  %52 = sub i64 %24, %3
  %53 = add i64 %49, %3
  %54 = load %struct.kmalloc_info*, %struct.kmalloc_info** @next_free_block, align 8, !tbaa !1
  %55 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %54, i64 0, i32 0
  store i64 %53, i64* %55, align 8, !tbaa !16
  %56 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %54, i64 0, i32 1
  store i64 %52, i64* %56, align 8, !tbaa !18
  %57 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0.lcssa, i64 0, i32 2
  %58 = bitcast %struct.kmalloc_info** %57 to i64*
  %59 = load i64, i64* %58, align 8, !tbaa !19
  %60 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %54, i64 0, i32 2
  %61 = bitcast %struct.kmalloc_info** %60 to i64*
  store i64 %59, i64* %61, align 8, !tbaa !19
  %62 = load %struct.kmalloc_info*, %struct.kmalloc_info** @next_free_block, align 8, !tbaa !1
  %63 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %62, i64 0, i32 0
  %64 = load i64, i64* %63, align 8, !tbaa !16
  %65 = and i64 %64, -2
  store i64 %65, i64* %63, align 8, !tbaa !16
  %66 = ptrtoint %struct.kmalloc_info* %62 to i64
  store i64 %66, i64* %58, align 8, !tbaa !19
  %67 = load %struct.kmalloc_info*, %struct.kmalloc_info** @next_free_block, align 8, !tbaa !1
  %68 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %67, i64 1
  store %struct.kmalloc_info* %68, %struct.kmalloc_info** @next_free_block, align 8, !tbaa !1
  %.pre = load i64, i64* %20, align 8, !tbaa !16
  br label %69

; <label>:69                                      ; preds = %48, %51
  %70 = phi i64 [ %21, %48 ], [ %.pre, %51 ]
  %71 = or i64 %70, 1
  store i64 %71, i64* %20, align 8, !tbaa !16
  store i64 %3, i64* %23, align 8, !tbaa !18
  %72 = load i64*, i64** @alloc_sync, align 8, !tbaa !1
  %73 = tail call zeroext i8 @UnlockSpinlock(i64* %72) #3
  %74 = inttoptr i64 %49 to i8*
  %75 = inttoptr i64 %49 to i64*
  store i64 -2401053089206453570, i64* %75, align 8, !tbaa !5
  %76 = getelementptr inbounds i8, i8* %74, i64 8
  %77 = bitcast i8* %76 to i64*
  store i64 %size, i64* %77, align 8, !tbaa !5
  %78 = getelementptr inbounds i8, i8* %74, i64 16
  %79 = bitcast i8* %78 to i64*
  store i64 -2401053089206453570, i64* %79, align 8, !tbaa !5
  %80 = add i64 %49, 24
  %81 = add i64 %80, %size
  %82 = inttoptr i64 %81 to i64*
  store i64 -2401050963649814811, i64* %82, align 8, !tbaa !5
  %83 = getelementptr inbounds i64, i64* %82, i64 1
  store i64 %size, i64* %83, align 8, !tbaa !5
  %84 = getelementptr inbounds i64, i64* %82, i64 2
  store i64 -2401050963649814811, i64* %84, align 8, !tbaa !5
  %85 = inttoptr i64 %80 to i8*
  br label %86

; <label>:86                                      ; preds = %29, %69
  %.0 = phi i8* [ %85, %69 ], [ null, %29 ]
  ret i8* %.0
}

; Function Attrs: noredzone
declare zeroext i8 @LockSpinlock(i64*) #1

; Function Attrs: noredzone
declare zeroext i8 @UnlockSpinlock(i64*) #1

; Function Attrs: noredzone nounwind uwtable
define void @kfree(i8* %addr) #0 {
  %1 = load i64*, i64** @alloc_sync, align 8, !tbaa !1
  %2 = tail call zeroext i8 @LockSpinlock(i64* %1) #3
  %3 = ptrtoint i8* %addr to i64
  %4 = add i64 %3, -24
  %5 = inttoptr i64 %4 to i64*
  %6 = load i64, i64* %5, align 8, !tbaa !5
  %7 = icmp eq i64 %6, -2401053089206453570
  br i1 %7, label %.preheader, label %8

; <label>:8                                       ; preds = %0
  tail call void asm sideeffect "add $$0x28, %rsp\0A\09popq %rbx\0A\09cli\0A\09hlt", "{ax},~{dirflag},~{fpsr},~{flags}"(i8* %addr) #2, !srcloc !21
  br label %.preheader

.preheader:                                       ; preds = %0, %8
  %a_info.0.pre = load %struct.kmalloc_info*, %struct.kmalloc_info** @allocation_info, align 8
  br label %9

; <label>:9                                       ; preds = %.preheader, %13
  %a_info.0 = phi %struct.kmalloc_info* [ %11, %13 ], [ %a_info.0.pre, %.preheader ]
  %10 = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0, i64 0, i32 2
  %11 = load %struct.kmalloc_info*, %struct.kmalloc_info** %10, align 8, !tbaa !19
  %12 = icmp eq %struct.kmalloc_info* %11, null
  %.phi.trans.insert = getelementptr inbounds %struct.kmalloc_info, %struct.kmalloc_info* %a_info.0, i64 0, i32 0
  %.pre = load i64, i64* %.phi.trans.insert, align 8, !tbaa !16
  br i1 %12, label %.loopexit, label %13

; <label>:13                                      ; preds = %9
  %14 = and i64 %.pre, 1
  %15 = icmp ne i64 %14, 0
  %16 = icmp eq i64 %.pre, %3
  %or.cond = and i1 %16, %15
  br i1 %or.cond, label %.loopexit, label %9

.loopexit:                                        ; preds = %13, %9
  %.phi.trans.insert.lcssa = phi i64* [ %.phi.trans.insert, %13 ], [ %.phi.trans.insert, %9 ]
  %17 = phi i64 [ %.pre, %9 ], [ %3, %13 ]
  %18 = and i64 %17, -2
  store i64 %18, i64* %.phi.trans.insert.lcssa, align 8, !tbaa !16
  %19 = load i64*, i64** @alloc_sync, align 8, !tbaa !1
  %20 = tail call zeroext i8 @UnlockSpinlock(i64* %19) #3
  ret void
}

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { nobuiltin noredzone nounwind }
attributes #4 = { nobuiltin noredzone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"any pointer", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!6, !6, i64 0}
!6 = !{!"long", !3, i64 0}
!7 = !{!8, !3, i64 0}
!8 = !{!"MemoryAllocationsMap", !3, i64 0, !6, i64 8, !6, i64 16, !6, i64 24, !3, i64 32, !3, i64 36, !6, i64 40, !6, i64 48, !2, i64 56}
!9 = !{!8, !6, i64 8}
!10 = !{!8, !6, i64 24}
!11 = !{!8, !3, i64 36}
!12 = !{!8, !6, i64 40}
!13 = !{!8, !6, i64 48}
!14 = !{!15, !15, i64 0}
!15 = !{!"int", !3, i64 0}
!16 = !{!17, !6, i64 0}
!17 = !{!"kmalloc_info", !6, i64 0, !6, i64 8, !2, i64 16}
!18 = !{!17, !6, i64 8}
!19 = !{!17, !2, i64 16}
!20 = !{!3, !3, i64 0}
!21 = !{i32 5696, i32 5715, i32 5729, i32 5736}
