; ModuleID = 'hal/program.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.ProcessInformation = type { i64, [256 x i8], i32, i32, i32, [22 x void (i32)*], i64, %struct.MemoryAllocationsMap*, %struct.List*, i32, i64* }
%struct.MemoryAllocationsMap = type { i32, i64, i64, i64, i32, i32, i64, i64, %struct.MemoryAllocationsMap* }
%struct.List = type opaque
%struct.ElfInformation = type { i8*, i8*, i64, i64 }
%struct.AUXVector = type { i32, %union.anon }
%union.anon = type { i64 }

; Function Attrs: noredzone nounwind uwtable
define void @LoadAndStartApplication(i8* %elf_loc, i64 %elf_size, i8** nocapture readonly %argv, i32 %argc, i8** %envp) #0 {
  %p_info = alloca %struct.ProcessInformation, align 8
  %m = alloca %struct.MemoryAllocationsMap*, align 8
  %elf_info = alloca %struct.ElfInformation, align 8
  %auxv = alloca [8 x %struct.AUXVector], align 16
  %1 = bitcast %struct.ProcessInformation* %p_info to i8*
  call void @llvm.lifetime.start(i64 496, i8* %1) #1
  %2 = tail call i64 @GetCurrentProcessUID() #3
  %3 = call i32 @GetProcessInformation(i64 %2, %struct.ProcessInformation* nonnull %p_info) #3
  %4 = bitcast %struct.MemoryAllocationsMap** %m to i8*
  call void @llvm.lifetime.start(i64 8, i8* %4) #1
  %5 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %p_info, i64 0, i32 7
  %6 = bitcast %struct.MemoryAllocationsMap** %5 to i64*
  %7 = load i64, i64* %6, align 8, !tbaa !1
  %8 = bitcast %struct.MemoryAllocationsMap** %m to i64*
  store i64 %7, i64* %8, align 8, !tbaa !7
  %9 = bitcast %struct.ElfInformation* %elf_info to i8*
  call void @llvm.lifetime.start(i64 32, i8* %9) #1
  %10 = call i64 @GetActiveVirtualMemoryInstance() #3
  %11 = call i32 @LoadElf(i8* %elf_loc, i64 %elf_size, i32 0, i64 %10, %struct.MemoryAllocationsMap** nonnull %m, %struct.ElfInformation* nonnull %elf_info) #3
  %12 = icmp eq i32 %11, 0
  br i1 %12, label %14, label %13

; <label>:13                                      ; preds = %0
  call void asm sideeffect "cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !8
  br label %14

; <label>:14                                      ; preds = %0, %13
  %15 = bitcast [8 x %struct.AUXVector]* %auxv to i8*
  call void @llvm.lifetime.start(i64 128, i8* %15) #1
  %16 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 0, i32 0
  store i32 6, i32* %16, align 16, !tbaa !9
  %17 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 0, i32 1, i32 0
  store i64 4096, i64* %17, align 8, !tbaa !12
  %18 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 1, i32 0
  store i32 11, i32* %18, align 16, !tbaa !9
  %19 = call i64 @GetCurrentThreadUID() #3
  %20 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 1, i32 1, i32 0
  store i64 %19, i64* %20, align 8, !tbaa !12
  %21 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 2, i32 0
  store i32 12, i32* %21, align 16, !tbaa !9
  %22 = call i64 @GetCurrentThreadUID() #3
  %23 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 2, i32 1, i32 0
  store i64 %22, i64* %23, align 8, !tbaa !12
  %24 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 3, i32 0
  store i32 13, i32* %24, align 16, !tbaa !9
  %25 = call i64 @GetCurrentProcessUID() #3
  %26 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 3, i32 1, i32 0
  store i64 %25, i64* %26, align 8, !tbaa !12
  %27 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 4, i32 0
  store i32 14, i32* %27, align 16, !tbaa !9
  %28 = call i64 @GetCurrentProcessUID() #3
  %29 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 4, i32 1, i32 0
  store i64 %28, i64* %29, align 8, !tbaa !12
  %30 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 5, i32 0
  store i32 25, i32* %30, align 16, !tbaa !9
  %31 = bitcast %struct.ElfInformation* %elf_info to i64*
  %32 = load i64, i64* %31, align 8, !tbaa !13
  %33 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 5, i32 1, i32 0
  store i64 %32, i64* %33, align 8, !tbaa !12
  %34 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 6, i32 0
  store i32 9, i32* %34, align 16, !tbaa !9
  %35 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 6, i32 1, i32 0
  store i64 %32, i64* %35, align 8, !tbaa !12
  %36 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 7, i32 0
  store i32 16, i32* %36, align 16, !tbaa !9
  %37 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 7, i32 1, i32 0
  store i64 3219913727, i64* %37, align 8, !tbaa !12
  %38 = call i64 @GetCurrentThreadUID() #3
  %39 = call i8* @GetThreadUserStack(i64 %38) #3
  %40 = getelementptr inbounds [8 x %struct.AUXVector], [8 x %struct.AUXVector]* %auxv, i64 0, i64 0
  %41 = call i8* @SetupApplicationStack(i8* %39, i32 %argc, i8** %argv, i8** %envp, %struct.AUXVector* %40, i32 8, %struct.ElfInformation* nonnull %elf_info) #4
  %42 = load i64, i64* %31, align 8, !tbaa !13
  %43 = ptrtoint i8* %41 to i64
  call void @SwitchToUserMode(i64 %42, i64 %43) #3
  call void @llvm.lifetime.end(i64 128, i8* %15) #1
  call void @llvm.lifetime.end(i64 32, i8* %9) #1
  call void @llvm.lifetime.end(i64 8, i8* %4) #1
  call void @llvm.lifetime.end(i64 496, i8* %1) #1
  ret void
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

; Function Attrs: noredzone
declare i32 @GetProcessInformation(i64, %struct.ProcessInformation*) #2

; Function Attrs: noredzone
declare i64 @GetCurrentProcessUID() #2

; Function Attrs: noredzone
declare i32 @LoadElf(i8*, i64, i32, i64, %struct.MemoryAllocationsMap**, %struct.ElfInformation*) #2

; Function Attrs: noredzone
declare i64 @GetActiveVirtualMemoryInstance() #2

; Function Attrs: noredzone
declare i64 @GetCurrentThreadUID() #2

; Function Attrs: noredzone nounwind uwtable
define i8* @SetupApplicationStack(i8* %sp, i32 %argc, i8** nocapture readonly %argv, i8** readonly %envp, %struct.AUXVector* nocapture readonly %aux_vectors, i32 %auxv_cnt, %struct.ElfInformation* nocapture readonly %elf) #0 {
  %v_tmp_addr = alloca i64, align 8
  %1 = bitcast i8* %sp to i64*
  %2 = icmp ne i8** %envp, null
  br i1 %2, label %.preheader3.preheader, label %.loopexit4

.preheader3.preheader:                            ; preds = %0
  br label %.preheader3

.preheader3:                                      ; preds = %.preheader3.preheader, %.preheader3
  %size.0 = phi i64 [ %6, %.preheader3 ], [ 0, %.preheader3.preheader ]
  %3 = getelementptr inbounds i8*, i8** %envp, i64 %size.0
  %4 = load i8*, i8** %3, align 8, !tbaa !7
  %5 = icmp eq i8* %4, null
  %6 = add i64 %size.0, 1
  br i1 %5, label %.loopexit4.loopexit, label %.preheader3

.loopexit4.loopexit:                              ; preds = %.preheader3
  %size.0.lcssa = phi i64 [ %size.0, %.preheader3 ]
  br label %.loopexit4

.loopexit4:                                       ; preds = %.loopexit4.loopexit, %0
  %size.1 = phi i64 [ 0, %0 ], [ %size.0.lcssa, %.loopexit4.loopexit ]
  %7 = add i32 %argc, 2
  %8 = zext i32 %7 to i64
  %9 = add i32 %auxv_cnt, 4
  %10 = zext i32 %9 to i64
  %11 = shl nuw nsw i64 %10, 1
  %12 = add nuw nsw i64 %8, %11
  %13 = add i64 %12, %size.1
  %14 = sub i64 0, %13
  %15 = getelementptr inbounds i64, i64* %1, i64 %14
  %16 = bitcast i64* %v_tmp_addr to i8*
  call void @llvm.lifetime.start(i64 8, i8* %16) #1
  store i64 0, i64* %v_tmp_addr, align 8, !tbaa !12
  %17 = tail call i64 @GetActiveVirtualMemoryInstance() #3
  %18 = call i32 @FindFreeVirtualAddress(i64 %17, i64* nonnull %v_tmp_addr, i64 4096, i32 0, i32 12) #3
  %19 = call i8* @kmalloc(i64 64) #3
  %20 = bitcast i8* %19 to %struct.MemoryAllocationsMap*
  %21 = call i64 @AllocatePhysicalPage() #3
  %22 = call i64 @GetActiveVirtualMemoryInstance() #3
  %23 = load i64, i64* %v_tmp_addr, align 8, !tbaa !12
  %24 = call i32 @MapPage(i64 %22, %struct.MemoryAllocationsMap* %20, i64 %21, i64 %23, i64 4096, i32 0, i32 0, i32 12) #3
  %25 = bitcast i64* %v_tmp_addr to i8**
  %26 = load i8*, i8** %25, align 8, !tbaa !12
  %27 = icmp eq i32 %argc, 0
  br i1 %27, label %._crit_edge.15, label %.lr.ph14.preheader

.lr.ph14.preheader:                               ; preds = %.loopexit4
  br label %.lr.ph14

._crit_edge.15.loopexit:                          ; preds = %.lr.ph14
  %.lcssa27 = phi i64 [ %42, %.lr.ph14 ]
  br label %._crit_edge.15

._crit_edge.15:                                   ; preds = %._crit_edge.15.loopexit, %.loopexit4
  %off.0.lcssa = phi i64 [ 0, %.loopexit4 ], [ %.lcssa27, %._crit_edge.15.loopexit ]
  %28 = zext i32 %argc to i64
  store i64 %28, i64* %15, align 8, !tbaa !12
  %29 = add i32 %argc, 1
  %30 = zext i32 %29 to i64
  %31 = getelementptr inbounds i64, i64* %15, i64 %30
  store i64 0, i64* %31, align 8, !tbaa !12
  br i1 %2, label %.preheader, label %.loopexit

.preheader:                                       ; preds = %._crit_edge.15
  %32 = load i8*, i8** %envp, align 8, !tbaa !7
  %33 = icmp eq i8* %32, null
  br i1 %33, label %.loopexit, label %.lr.ph9.preheader

.lr.ph9.preheader:                                ; preds = %.preheader
  br label %.lr.ph9

.lr.ph14:                                         ; preds = %.lr.ph14.preheader, %.lr.ph14
  %indvars.iv20 = phi i64 [ %indvars.iv.next21, %.lr.ph14 ], [ 0, %.lr.ph14.preheader ]
  %off.011 = phi i64 [ %42, %.lr.ph14 ], [ 0, %.lr.ph14.preheader ]
  %34 = getelementptr inbounds i8, i8* %26, i64 %off.011
  %35 = ptrtoint i8* %34 to i64
  %indvars.iv.next21 = add nuw nsw i64 %indvars.iv20, 1
  %36 = getelementptr inbounds i64, i64* %15, i64 %indvars.iv.next21
  store i64 %35, i64* %36, align 8, !tbaa !12
  %37 = getelementptr inbounds i8*, i8** %argv, i64 %indvars.iv20
  %38 = load i8*, i8** %37, align 8, !tbaa !7
  %39 = call i8* @strcpy(i8* %34, i8* %38) #3
  %40 = load i8*, i8** %37, align 8, !tbaa !7
  %41 = call i64 @strlen(i8* %40) #3
  %42 = add i64 %41, %off.011
  %lftr.wideiv22 = trunc i64 %indvars.iv.next21 to i32
  %exitcond23 = icmp eq i32 %lftr.wideiv22, %argc
  br i1 %exitcond23, label %._crit_edge.15.loopexit, label %.lr.ph14

.lr.ph9:                                          ; preds = %.lr.ph9.preheader, %.lr.ph9
  %43 = phi i8* [ %51, %.lr.ph9 ], [ %32, %.lr.ph9.preheader ]
  %i1.08 = phi i32 [ %48, %.lr.ph9 ], [ 0, %.lr.ph9.preheader ]
  %offset.07 = phi i32 [ %45, %.lr.ph9 ], [ %7, %.lr.ph9.preheader ]
  %44 = ptrtoint i8* %43 to i64
  %45 = add i32 %offset.07, 1
  %46 = zext i32 %offset.07 to i64
  %47 = getelementptr inbounds i64, i64* %15, i64 %46
  store i64 %44, i64* %47, align 8, !tbaa !12
  %48 = add i32 %i1.08, 1
  %49 = zext i32 %48 to i64
  %50 = getelementptr inbounds i8*, i8** %envp, i64 %49
  %51 = load i8*, i8** %50, align 8, !tbaa !7
  %52 = icmp eq i8* %51, null
  br i1 %52, label %.loopexit.loopexit, label %.lr.ph9

.loopexit.loopexit:                               ; preds = %.lr.ph9
  %.lcssa = phi i32 [ %45, %.lr.ph9 ]
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %._crit_edge.15
  %offset.1 = phi i32 [ %7, %._crit_edge.15 ], [ %7, %.preheader ], [ %.lcssa, %.loopexit.loopexit ]
  %53 = add i32 %offset.1, 1
  %54 = zext i32 %offset.1 to i64
  %55 = getelementptr inbounds i64, i64* %15, i64 %54
  store i64 0, i64* %55, align 8, !tbaa !12
  %56 = zext i32 %53 to i64
  %57 = getelementptr inbounds i64, i64* %15, i64 %56
  %58 = bitcast i64* %57 to %struct.AUXVector*
  %59 = icmp eq i32 %auxv_cnt, 0
  br i1 %59, label %80, label %.lr.ph

.lr.ph:                                           ; preds = %.loopexit
  %60 = add i32 %auxv_cnt, -1
  %61 = zext i32 %60 to i64
  %62 = shl nuw nsw i64 %61, 4
  %63 = shl nuw nsw i64 %56, 3
  %64 = add nuw nsw i64 %62, %63
  %65 = add nuw nsw i64 %64, 16
  %66 = add i64 %size.1, %11
  %67 = add i64 %66, %8
  %68 = shl i64 %67, 3
  %69 = sub i64 %65, %68
  %scevgep = getelementptr i8, i8* %sp, i64 %69
  %xtraiter = and i32 %auxv_cnt, 1
  %lcmp.mod = icmp eq i32 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.split, label %70

; <label>:70                                      ; preds = %.lr.ph
  %71 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %aux_vectors, i64 0, i32 0
  %72 = load i32, i32* %71, align 4, !tbaa !9
  %73 = bitcast i64* %57 to i32*
  store i32 %72, i32* %73, align 4, !tbaa !9
  %74 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %aux_vectors, i64 0, i32 1, i32 0
  %75 = load i64, i64* %74, align 8, !tbaa !12
  %76 = getelementptr inbounds i64, i64* %57, i64 1
  store i64 %75, i64* %76, align 8, !tbaa !12
  %77 = getelementptr inbounds i64, i64* %57, i64 2
  %78 = bitcast i64* %77 to %struct.AUXVector*
  br label %.lr.ph.split

.lr.ph.split:                                     ; preds = %.lr.ph, %70
  %indvars.iv.unr = phi i64 [ 0, %.lr.ph ], [ 1, %70 ]
  %auxv.05.unr = phi %struct.AUXVector* [ %58, %.lr.ph ], [ %78, %70 ]
  %79 = icmp eq i32 %auxv_cnt, 1
  br i1 %79, label %._crit_edge, label %.lr.ph.split.split

.lr.ph.split.split:                               ; preds = %.lr.ph.split
  br label %102

._crit_edge.unr-lcssa:                            ; preds = %102
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph.split, %._crit_edge.unr-lcssa
  %scevgep19 = bitcast i8* %scevgep to %struct.AUXVector*
  br label %80

; <label>:80                                      ; preds = %.loopexit, %._crit_edge
  %auxv.0.lcssa = phi %struct.AUXVector* [ %scevgep19, %._crit_edge ], [ %58, %.loopexit ]
  %81 = getelementptr inbounds i8, i8* %26, i64 %off.0.lcssa
  %82 = getelementptr inbounds %struct.ElfInformation, %struct.ElfInformation* %elf, i64 0, i32 1
  %83 = load i8*, i8** %82, align 8, !tbaa !15
  %84 = getelementptr inbounds %struct.ElfInformation, %struct.ElfInformation* %elf, i64 0, i32 2
  %85 = load i64, i64* %84, align 8, !tbaa !16
  %86 = getelementptr inbounds %struct.ElfInformation, %struct.ElfInformation* %elf, i64 0, i32 3
  %87 = load i64, i64* %86, align 8, !tbaa !17
  %88 = mul i64 %87, %85
  %89 = call i8* @memcpy(i8* %81, i8* %83, i64 %88) #3
  %90 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 0, i32 0
  store i32 3, i32* %90, align 4, !tbaa !9
  %91 = ptrtoint i8* %81 to i64
  %92 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 0, i32 1, i32 0
  store i64 %91, i64* %92, align 8, !tbaa !12
  %93 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 1, i32 0
  store i32 5, i32* %93, align 4, !tbaa !9
  %94 = load i64, i64* %84, align 8, !tbaa !16
  %95 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 1, i32 1, i32 0
  store i64 %94, i64* %95, align 8, !tbaa !12
  %96 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 2, i32 0
  store i32 4, i32* %96, align 4, !tbaa !9
  %97 = load i64, i64* %86, align 8, !tbaa !17
  %98 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 2, i32 1, i32 0
  store i64 %97, i64* %98, align 8, !tbaa !12
  %99 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 3, i32 0
  store i32 0, i32* %99, align 4, !tbaa !9
  %100 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.0.lcssa, i64 3, i32 1, i32 0
  store i64 0, i64* %100, align 8, !tbaa !12
  %101 = bitcast i64* %15 to i8*
  call void @llvm.lifetime.end(i64 8, i8* %16) #1
  ret i8* %101

; <label>:102                                     ; preds = %102, %.lr.ph.split.split
  %indvars.iv = phi i64 [ %indvars.iv.unr, %.lr.ph.split.split ], [ %indvars.iv.next.1, %102 ]
  %auxv.05 = phi %struct.AUXVector* [ %auxv.05.unr, %.lr.ph.split.split ], [ %115, %102 ]
  %103 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %aux_vectors, i64 %indvars.iv, i32 0
  %104 = load i32, i32* %103, align 4, !tbaa !9
  %105 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.05, i64 0, i32 0
  store i32 %104, i32* %105, align 4, !tbaa !9
  %106 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %aux_vectors, i64 %indvars.iv, i32 1, i32 0
  %107 = load i64, i64* %106, align 8, !tbaa !12
  %108 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.05, i64 0, i32 1, i32 0
  store i64 %107, i64* %108, align 8, !tbaa !12
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %109 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %aux_vectors, i64 %indvars.iv.next, i32 0
  %110 = load i32, i32* %109, align 4, !tbaa !9
  %111 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.05, i64 1, i32 0
  store i32 %110, i32* %111, align 4, !tbaa !9
  %112 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %aux_vectors, i64 %indvars.iv.next, i32 1, i32 0
  %113 = load i64, i64* %112, align 8, !tbaa !12
  %114 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.05, i64 1, i32 1, i32 0
  store i64 %113, i64* %114, align 8, !tbaa !12
  %115 = getelementptr inbounds %struct.AUXVector, %struct.AUXVector* %auxv.05, i64 2
  %indvars.iv.next.1 = add nsw i64 %indvars.iv, 2
  %lftr.wideiv.1 = trunc i64 %indvars.iv.next.1 to i32
  %exitcond.1 = icmp eq i32 %lftr.wideiv.1, %auxv_cnt
  br i1 %exitcond.1, label %._crit_edge.unr-lcssa, label %102
}

; Function Attrs: noredzone
declare i8* @GetThreadUserStack(i64) #2

; Function Attrs: noredzone
declare void @SwitchToUserMode(i64, i64) #2

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

; Function Attrs: noredzone
declare i32 @FindFreeVirtualAddress(i64, i64*, i64, i32, i32) #2

; Function Attrs: noredzone
declare i8* @kmalloc(i64) #2

; Function Attrs: noredzone
declare i64 @AllocatePhysicalPage() #2

; Function Attrs: noredzone
declare i32 @MapPage(i64, %struct.MemoryAllocationsMap*, i64, i64, i64, i32, i32, i32) #2

; Function Attrs: noredzone
declare i8* @strcpy(i8*, i8*) #2

; Function Attrs: noredzone
declare i64 @strlen(i8*) #2

; Function Attrs: noredzone
declare i8* @memcpy(i8*, i8*, i64) #2

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nobuiltin noredzone nounwind }
attributes #4 = { nobuiltin noredzone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !6, i64 464}
!2 = !{!"ProcessInformation", !3, i64 0, !4, i64 8, !4, i64 264, !4, i64 268, !4, i64 272, !4, i64 280, !3, i64 456, !6, i64 464, !6, i64 472, !4, i64 480, !6, i64 488}
!3 = !{!"long", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!"any pointer", !4, i64 0}
!7 = !{!6, !6, i64 0}
!8 = !{i32 693, i32 699}
!9 = !{!10, !11, i64 0}
!10 = !{!"", !11, i64 0, !4, i64 8}
!11 = !{!"int", !4, i64 0}
!12 = !{!3, !3, i64 0}
!13 = !{!14, !6, i64 0}
!14 = !{!"ElfInformation", !6, i64 0, !6, i64 8, !3, i64 16, !3, i64 24}
!15 = !{!14, !6, i64 8}
!16 = !{!14, !3, i64 16}
!17 = !{!14, !3, i64 24}
