; ModuleID = 'page_manager/phys_mem_manager.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.CardinalBootInfo = type { i64, i32, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.CardinalMemMap*, i64, i32, i32, i32, i8 }
%struct.CardinalMemMap = type { i64, i64, i8 }

@memory_size = internal unnamed_addr global i64 0, align 8
@page_count = internal unnamed_addr global i64 0, align 8
@freePageCount = internal unnamed_addr global i64 0, align 8
@lastNonFullPage = internal unnamed_addr global i64 0, align 8
@KB4_Blocks_Count = internal unnamed_addr global i32 0, align 4
@KB4_Blocks_Bitmap = internal unnamed_addr global i32* null, align 8
@_region_kernel_start_ = external global i64, align 8
@_region_kernel_end_ = external global i64, align 8

; Function Attrs: noredzone nounwind uwtable
define i32 @MemMan_Initialize() #0 {
  %1 = tail call %struct.CardinalBootInfo* @GetBootInfo() #2
  %2 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 0
  %3 = load i64, i64* %2, align 8, !tbaa !1
  %4 = and i64 %3, -4096
  store i64 %4, i64* @memory_size, align 8, !tbaa !8
  %5 = lshr i64 %3, 12
  store i64 %5, i64* @page_count, align 8, !tbaa !8
  store i64 %5, i64* @freePageCount, align 8, !tbaa !8
  %6 = icmp ult i64 %3, 2147487744
  %7 = lshr i64 %3, 18
  %8 = add nsw i64 %7, -1
  %storemerge = select i1 %6, i64 %8, i64 0
  store i64 %storemerge, i64* @lastNonFullPage, align 8, !tbaa !8
  %9 = lshr i64 %3, 17
  %10 = trunc i64 %9 to i32
  store i32 %10, i32* @KB4_Blocks_Count, align 4, !tbaa !9
  %11 = shl nuw nsw i64 %9, 2
  %12 = and i64 %11, 17179869180
  %13 = tail call i8* @bootstrap_malloc(i64 %12) #2
  store i8* %13, i8** bitcast (i32** @KB4_Blocks_Bitmap to i8**), align 8, !tbaa !10
  %14 = load i32, i32* @KB4_Blocks_Count, align 4, !tbaa !9
  %15 = zext i32 %14 to i64
  %16 = shl nuw nsw i64 %15, 2
  %17 = tail call i8* @memset(i8* %13, i32 -1, i64 %16) #2
  %18 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 6
  %19 = load i32, i32* %18, align 4, !tbaa !11
  %20 = icmp ugt i32 %19, 23
  br i1 %20, label %.lr.ph, label %._crit_edge

.lr.ph:                                           ; preds = %0
  %21 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 11
  %22 = load %struct.CardinalMemMap*, %struct.CardinalMemMap** %21, align 8, !tbaa !12
  %23 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  br label %161

._crit_edge.loopexit:                             ; preds = %MemMan_MarkFree.exit
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %0
  %24 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 12
  %25 = bitcast i64* %24 to i8**
  %26 = load i8*, i8** %25, align 8, !tbaa !13
  %27 = tail call i8* @GetPhysicalAddress(i8* %26) #2
  %28 = ptrtoint i8* %27 to i64
  %29 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 13
  %30 = load i32, i32* %29, align 4, !tbaa !14
  %31 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 15
  %32 = load i32, i32* %31, align 4, !tbaa !15
  %33 = mul i32 %32, %30
  %34 = zext i32 %33 to i64
  %35 = icmp eq i32 %33, 0
  br i1 %35, label %MemMan_MarkUsed.exit, label %36

; <label>:36                                      ; preds = %._crit_edge
  %37 = and i64 %34, 4095
  %38 = icmp eq i64 %37, 0
  %39 = add nuw nsw i64 %34, 4096
  %.0.i = select i1 %38, i64 %34, i64 %39
  %40 = lshr i64 %.0.i, 12
  %41 = icmp eq i64 %40, 0
  br i1 %41, label %MemMan_MarkUsed.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %36
  %42 = and i64 %28, -4096
  %43 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted.i = load i64, i64* @freePageCount, align 8, !tbaa !8
  %44 = lshr i64 %.0.i, 12
  %xtraiter37 = and i64 %44, 1
  %lcmp.mod38 = icmp eq i64 %xtraiter37, 0
  br i1 %lcmp.mod38, label %.lr.ph.i.split, label %45

; <label>:45                                      ; preds = %.lr.ph.i
  %46 = lshr i64 %28, 12
  %.tr.i.i.prol = trunc i64 %46 to i32
  %47 = and i32 %.tr.i.i.prol, 31
  %48 = shl i32 1, %47
  %49 = lshr i64 %28, 17
  %50 = getelementptr inbounds i32, i32* %43, i64 %49
  %51 = load i32, i32* %50, align 4, !tbaa !9
  %52 = or i32 %48, %51
  store i32 %52, i32* %50, align 4, !tbaa !9
  %53 = add i64 %42, 4096
  br label %.lr.ph.i.split

.lr.ph.i.split:                                   ; preds = %.lr.ph.i, %45
  %i.03.i.unr = phi i64 [ 0, %.lr.ph.i ], [ 1, %45 ]
  %.012.i.unr = phi i64 [ %42, %.lr.ph.i ], [ %53, %45 ]
  %54 = icmp eq i64 %44, 1
  br i1 %54, label %..loopexit_crit_edge.i, label %.lr.ph.i.split.split

.lr.ph.i.split.split:                             ; preds = %.lr.ph.i.split
  br label %55

; <label>:55                                      ; preds = %55, %.lr.ph.i.split.split
  %i.03.i = phi i64 [ %i.03.i.unr, %.lr.ph.i.split.split ], [ %72, %55 ]
  %.012.i = phi i64 [ %.012.i.unr, %.lr.ph.i.split.split ], [ %71, %55 ]
  %56 = lshr i64 %.012.i, 12
  %.tr.i.i = trunc i64 %56 to i32
  %57 = and i32 %.tr.i.i, 31
  %58 = shl i32 1, %57
  %59 = lshr i64 %.012.i, 17
  %60 = getelementptr inbounds i32, i32* %43, i64 %59
  %61 = load i32, i32* %60, align 4, !tbaa !9
  %62 = or i32 %58, %61
  store i32 %62, i32* %60, align 4, !tbaa !9
  %63 = add i64 %.012.i, 4096
  %64 = lshr i64 %63, 12
  %.tr.i.i.1 = trunc i64 %64 to i32
  %65 = and i32 %.tr.i.i.1, 31
  %66 = shl i32 1, %65
  %67 = lshr i64 %63, 17
  %68 = getelementptr inbounds i32, i32* %43, i64 %67
  %69 = load i32, i32* %68, align 4, !tbaa !9
  %70 = or i32 %66, %69
  store i32 %70, i32* %68, align 4, !tbaa !9
  %71 = add i64 %.012.i, 8192
  %72 = add nsw i64 %i.03.i, 2
  %exitcond.i.1 = icmp eq i64 %72, %40
  br i1 %exitcond.i.1, label %..loopexit_crit_edge.i.unr-lcssa, label %55

..loopexit_crit_edge.i.unr-lcssa:                 ; preds = %55
  br label %..loopexit_crit_edge.i

..loopexit_crit_edge.i:                           ; preds = %.lr.ph.i.split, %..loopexit_crit_edge.i.unr-lcssa
  %73 = sub i64 %freePageCount.promoted.i, %40
  store i64 %73, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_MarkUsed.exit

MemMan_MarkUsed.exit:                             ; preds = %._crit_edge, %36, %..loopexit_crit_edge.i
  br i1 or (i1 icmp eq (i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 0), i1 icmp eq (i64 lshr (i64 select (i1 icmp eq (i64 and (i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 4095), i64 0), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 8192)), i64 12), i64 0)), label %MemMan_MarkUsed.exit34, label %.lr.ph.i.28

.lr.ph.i.28:                                      ; preds = %MemMan_MarkUsed.exit
  %74 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted.i.27 = load i64, i64* @freePageCount, align 8, !tbaa !8
  br i1 icmp ne (i64 and (i64 lshr (i64 select (i1 icmp eq (i64 and (i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 4095), i64 0), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 8192)), i64 12), i64 1), i64 0), label %75, label %.lr.ph.i.28.split

; <label>:75                                      ; preds = %.lr.ph.i.28
  %76 = getelementptr inbounds i32, i32* %74, i64 lshr (i64 and (i64 ptrtoint (i64* @_region_kernel_start_ to i64), i64 -4096), i64 17)
  %77 = load i32, i32* %76, align 4, !tbaa !9
  %78 = or i32 %77, shl (i32 1, i32 and (i32 trunc (i64 lshr (i64 and (i64 ptrtoint (i64* @_region_kernel_start_ to i64), i64 -4096), i64 12) to i32), i32 31))
  store i32 %78, i32* %76, align 4, !tbaa !9
  br label %.lr.ph.i.28.split

.lr.ph.i.28.split:                                ; preds = %75, %.lr.ph.i.28
  %i.03.i.29.unr = phi i64 [ 0, %.lr.ph.i.28 ], [ 1, %75 ]
  %.012.i.30.unr = phi i64 [ and (i64 ptrtoint (i64* @_region_kernel_start_ to i64), i64 -4096), %.lr.ph.i.28 ], [ add (i64 and (i64 ptrtoint (i64* @_region_kernel_start_ to i64), i64 -4096), i64 4096), %75 ]
  br i1 icmp ult (i64 add (i64 lshr (i64 select (i1 icmp eq (i64 and (i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 4095), i64 0), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 8192)), i64 12), i64 -1), i64 1), label %..loopexit_crit_edge.i.33, label %.lr.ph.i.28.split.split

.lr.ph.i.28.split.split:                          ; preds = %.lr.ph.i.28.split
  br label %79

; <label>:79                                      ; preds = %79, %.lr.ph.i.28.split.split
  %i.03.i.29 = phi i64 [ %i.03.i.29.unr, %.lr.ph.i.28.split.split ], [ %96, %79 ]
  %.012.i.30 = phi i64 [ %.012.i.30.unr, %.lr.ph.i.28.split.split ], [ %95, %79 ]
  %80 = lshr i64 %.012.i.30, 12
  %.tr.i.i.31 = trunc i64 %80 to i32
  %81 = and i32 %.tr.i.i.31, 31
  %82 = shl i32 1, %81
  %83 = lshr i64 %.012.i.30, 17
  %84 = getelementptr inbounds i32, i32* %74, i64 %83
  %85 = load i32, i32* %84, align 4, !tbaa !9
  %86 = or i32 %82, %85
  store i32 %86, i32* %84, align 4, !tbaa !9
  %87 = add i64 %.012.i.30, 4096
  %88 = lshr i64 %87, 12
  %.tr.i.i.31.1 = trunc i64 %88 to i32
  %89 = and i32 %.tr.i.i.31.1, 31
  %90 = shl i32 1, %89
  %91 = lshr i64 %87, 17
  %92 = getelementptr inbounds i32, i32* %74, i64 %91
  %93 = load i32, i32* %92, align 4, !tbaa !9
  %94 = or i32 %90, %93
  store i32 %94, i32* %92, align 4, !tbaa !9
  %95 = add i64 %.012.i.30, 8192
  %96 = add nsw i64 %i.03.i.29, 2
  %exitcond.i.32.1 = icmp eq i64 %96, lshr (i64 select (i1 icmp eq (i64 and (i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 4095), i64 0), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 8192)), i64 12)
  br i1 %exitcond.i.32.1, label %..loopexit_crit_edge.i.33.unr-lcssa, label %79

..loopexit_crit_edge.i.33.unr-lcssa:              ; preds = %79
  br label %..loopexit_crit_edge.i.33

..loopexit_crit_edge.i.33:                        ; preds = %.lr.ph.i.28.split, %..loopexit_crit_edge.i.33.unr-lcssa
  %97 = sub i64 %freePageCount.promoted.i.27, lshr (i64 select (i1 icmp eq (i64 and (i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 4095), i64 0), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 4096), i64 add (i64 sub (i64 ptrtoint (i64* @_region_kernel_end_ to i64), i64 ptrtoint (i64* @_region_kernel_start_ to i64)), i64 8192)), i64 12)
  store i64 %97, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_MarkUsed.exit34

MemMan_MarkUsed.exit34:                           ; preds = %MemMan_MarkUsed.exit, %..loopexit_crit_edge.i.33
  %98 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 9
  %99 = load i64, i64* %98, align 8, !tbaa !16
  %100 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 10
  %101 = load i64, i64* %100, align 8, !tbaa !17
  %102 = icmp eq i64 %101, 0
  br i1 %102, label %MemMan_MarkUsed.exit25, label %103

; <label>:103                                     ; preds = %MemMan_MarkUsed.exit34
  %104 = and i64 %101, 4095
  %105 = icmp eq i64 %104, 0
  %106 = add i64 %101, 4096
  %.0.i.17 = select i1 %105, i64 %101, i64 %106
  %107 = lshr i64 %.0.i.17, 12
  %108 = icmp eq i64 %107, 0
  br i1 %108, label %MemMan_MarkUsed.exit25, label %.lr.ph.i.19

.lr.ph.i.19:                                      ; preds = %103
  %109 = and i64 %99, -4096
  %110 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted.i.18 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %111 = lshr i64 %.0.i.17, 12
  %xtraiter = and i64 %111, 1
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.i.19.split, label %112

; <label>:112                                     ; preds = %.lr.ph.i.19
  %113 = lshr i64 %99, 12
  %.tr.i.i.22.prol = trunc i64 %113 to i32
  %114 = and i32 %.tr.i.i.22.prol, 31
  %115 = shl i32 1, %114
  %116 = lshr i64 %99, 17
  %117 = getelementptr inbounds i32, i32* %110, i64 %116
  %118 = load i32, i32* %117, align 4, !tbaa !9
  %119 = or i32 %115, %118
  store i32 %119, i32* %117, align 4, !tbaa !9
  %120 = add i64 %109, 4096
  br label %.lr.ph.i.19.split

.lr.ph.i.19.split:                                ; preds = %.lr.ph.i.19, %112
  %i.03.i.20.unr = phi i64 [ 0, %.lr.ph.i.19 ], [ 1, %112 ]
  %.012.i.21.unr = phi i64 [ %109, %.lr.ph.i.19 ], [ %120, %112 ]
  %121 = icmp eq i64 %111, 1
  br i1 %121, label %..loopexit_crit_edge.i.24, label %.lr.ph.i.19.split.split

.lr.ph.i.19.split.split:                          ; preds = %.lr.ph.i.19.split
  br label %122

; <label>:122                                     ; preds = %122, %.lr.ph.i.19.split.split
  %i.03.i.20 = phi i64 [ %i.03.i.20.unr, %.lr.ph.i.19.split.split ], [ %139, %122 ]
  %.012.i.21 = phi i64 [ %.012.i.21.unr, %.lr.ph.i.19.split.split ], [ %138, %122 ]
  %123 = lshr i64 %.012.i.21, 12
  %.tr.i.i.22 = trunc i64 %123 to i32
  %124 = and i32 %.tr.i.i.22, 31
  %125 = shl i32 1, %124
  %126 = lshr i64 %.012.i.21, 17
  %127 = getelementptr inbounds i32, i32* %110, i64 %126
  %128 = load i32, i32* %127, align 4, !tbaa !9
  %129 = or i32 %125, %128
  store i32 %129, i32* %127, align 4, !tbaa !9
  %130 = add i64 %.012.i.21, 4096
  %131 = lshr i64 %130, 12
  %.tr.i.i.22.1 = trunc i64 %131 to i32
  %132 = and i32 %.tr.i.i.22.1, 31
  %133 = shl i32 1, %132
  %134 = lshr i64 %130, 17
  %135 = getelementptr inbounds i32, i32* %110, i64 %134
  %136 = load i32, i32* %135, align 4, !tbaa !9
  %137 = or i32 %133, %136
  store i32 %137, i32* %135, align 4, !tbaa !9
  %138 = add i64 %.012.i.21, 8192
  %139 = add nsw i64 %i.03.i.20, 2
  %exitcond.i.23.1 = icmp eq i64 %139, %107
  br i1 %exitcond.i.23.1, label %..loopexit_crit_edge.i.24.unr-lcssa, label %122

..loopexit_crit_edge.i.24.unr-lcssa:              ; preds = %122
  br label %..loopexit_crit_edge.i.24

..loopexit_crit_edge.i.24:                        ; preds = %.lr.ph.i.19.split, %..loopexit_crit_edge.i.24.unr-lcssa
  %140 = sub i64 %freePageCount.promoted.i.18, %107
  store i64 %140, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_MarkUsed.exit25

MemMan_MarkUsed.exit25:                           ; preds = %MemMan_MarkUsed.exit34, %103, %..loopexit_crit_edge.i.24
  %141 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted.i.9 = load i64, i64* @freePageCount, align 8, !tbaa !8
  br label %142

; <label>:142                                     ; preds = %142, %MemMan_MarkUsed.exit25
  %i.03.i.11 = phi i64 [ 0, %MemMan_MarkUsed.exit25 ], [ %159, %142 ]
  %.012.i.12 = phi i64 [ 0, %MemMan_MarkUsed.exit25 ], [ %158, %142 ]
  %143 = lshr exact i64 %.012.i.12, 12
  %.tr.i.i.13 = trunc i64 %143 to i32
  %144 = and i32 %.tr.i.i.13, 30
  %145 = shl i32 1, %144
  %146 = lshr i64 %.012.i.12, 17
  %147 = getelementptr inbounds i32, i32* %141, i64 %146
  %148 = load i32, i32* %147, align 4, !tbaa !9
  %149 = or i32 %145, %148
  store i32 %149, i32* %147, align 4, !tbaa !9
  %150 = lshr exact i64 %.012.i.12, 12
  %151 = or i64 %150, 1
  %.tr.i.i.13.1 = trunc i64 %151 to i32
  %152 = and i32 %.tr.i.i.13.1, 31
  %153 = shl i32 1, %152
  %154 = lshr i64 %.012.i.12, 17
  %155 = getelementptr inbounds i32, i32* %141, i64 %154
  %156 = load i32, i32* %155, align 4, !tbaa !9
  %157 = or i32 %153, %156
  store i32 %157, i32* %155, align 4, !tbaa !9
  %158 = add nsw i64 %.012.i.12, 8192
  %159 = add nsw i64 %i.03.i.11, 2
  %exitcond.i.14.1 = icmp eq i64 %159, 512
  br i1 %exitcond.i.14.1, label %MemMan_MarkUsed.exit16, label %142

MemMan_MarkUsed.exit16:                           ; preds = %142
  %160 = add i64 %freePageCount.promoted.i.9, -512
  store i64 %160, i64* @freePageCount, align 8, !tbaa !8
  ret i32 0

; <label>:161                                     ; preds = %.lr.ph, %MemMan_MarkFree.exit
  %162 = phi i32 [ %19, %.lr.ph ], [ %216, %MemMan_MarkFree.exit ]
  %163 = phi i64 [ 0, %.lr.ph ], [ %218, %MemMan_MarkFree.exit ]
  %j.036 = phi i32 [ 0, %.lr.ph ], [ %217, %MemMan_MarkFree.exit ]
  %164 = getelementptr inbounds %struct.CardinalMemMap, %struct.CardinalMemMap* %22, i64 %163, i32 0
  %165 = load i64, i64* %164, align 8, !tbaa !18
  %166 = and i64 %165, -4096
  %167 = getelementptr inbounds %struct.CardinalMemMap, %struct.CardinalMemMap* %22, i64 %163, i32 1
  %168 = load i64, i64* %167, align 8, !tbaa !20
  %169 = and i64 %168, 4095
  %170 = icmp eq i64 %169, 0
  %171 = add i64 %168, 4096
  %172 = and i64 %171, -4096
  %len.0 = select i1 %170, i64 %168, i64 %172
  %173 = getelementptr inbounds %struct.CardinalMemMap, %struct.CardinalMemMap* %22, i64 %163, i32 2
  %174 = load i8, i8* %173, align 1, !tbaa !21
  %175 = icmp ne i8 %174, 1
  %176 = icmp eq i64 %len.0, 0
  %or.cond = or i1 %175, %176
  br i1 %or.cond, label %MemMan_MarkFree.exit, label %177

; <label>:177                                     ; preds = %161
  %178 = and i64 %len.0, 4095
  %179 = icmp eq i64 %178, 0
  %180 = add i64 %len.0, 4096
  %.0.i.1 = select i1 %179, i64 %len.0, i64 %180
  %181 = lshr i64 %.0.i.1, 12
  %182 = icmp eq i64 %181, 0
  br i1 %182, label %MemMan_MarkFree.exit, label %.lr.ph.i.3

.lr.ph.i.3:                                       ; preds = %177
  %freePageCount.promoted.i.2 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %183 = lshr i64 %.0.i.1, 12
  %xtraiter39 = and i64 %183, 1
  %lcmp.mod40 = icmp eq i64 %xtraiter39, 0
  br i1 %lcmp.mod40, label %.lr.ph.i.3.split, label %184

; <label>:184                                     ; preds = %.lr.ph.i.3
  %185 = lshr i64 %165, 12
  %.tr.i.i.6.prol = trunc i64 %185 to i32
  %186 = and i32 %.tr.i.i.6.prol, 31
  %187 = shl i32 1, %186
  %188 = xor i32 %187, -1
  %189 = lshr i64 %165, 17
  %190 = getelementptr inbounds i32, i32* %23, i64 %189
  %191 = load i32, i32* %190, align 4, !tbaa !9
  %192 = and i32 %191, %188
  store i32 %192, i32* %190, align 4, !tbaa !9
  %193 = add i64 %166, 4096
  br label %.lr.ph.i.3.split

.lr.ph.i.3.split:                                 ; preds = %.lr.ph.i.3, %184
  %i.03.i.4.unr = phi i64 [ 0, %.lr.ph.i.3 ], [ 1, %184 ]
  %.012.i.5.unr = phi i64 [ %166, %.lr.ph.i.3 ], [ %193, %184 ]
  %194 = icmp eq i64 %183, 1
  br i1 %194, label %..loopexit_crit_edge.i.8, label %.lr.ph.i.3.split.split

.lr.ph.i.3.split.split:                           ; preds = %.lr.ph.i.3.split
  br label %195

; <label>:195                                     ; preds = %195, %.lr.ph.i.3.split.split
  %i.03.i.4 = phi i64 [ %i.03.i.4.unr, %.lr.ph.i.3.split.split ], [ %214, %195 ]
  %.012.i.5 = phi i64 [ %.012.i.5.unr, %.lr.ph.i.3.split.split ], [ %213, %195 ]
  %196 = lshr i64 %.012.i.5, 12
  %.tr.i.i.6 = trunc i64 %196 to i32
  %197 = and i32 %.tr.i.i.6, 31
  %198 = shl i32 1, %197
  %199 = xor i32 %198, -1
  %200 = lshr i64 %.012.i.5, 17
  %201 = getelementptr inbounds i32, i32* %23, i64 %200
  %202 = load i32, i32* %201, align 4, !tbaa !9
  %203 = and i32 %202, %199
  store i32 %203, i32* %201, align 4, !tbaa !9
  %204 = add i64 %.012.i.5, 4096
  %205 = lshr i64 %204, 12
  %.tr.i.i.6.1 = trunc i64 %205 to i32
  %206 = and i32 %.tr.i.i.6.1, 31
  %207 = shl i32 1, %206
  %208 = xor i32 %207, -1
  %209 = lshr i64 %204, 17
  %210 = getelementptr inbounds i32, i32* %23, i64 %209
  %211 = load i32, i32* %210, align 4, !tbaa !9
  %212 = and i32 %211, %208
  store i32 %212, i32* %210, align 4, !tbaa !9
  %213 = add i64 %.012.i.5, 8192
  %214 = add nsw i64 %i.03.i.4, 2
  %exitcond.i.7.1 = icmp eq i64 %214, %181
  br i1 %exitcond.i.7.1, label %..loopexit_crit_edge.i.8.unr-lcssa, label %195

..loopexit_crit_edge.i.8.unr-lcssa:               ; preds = %195
  br label %..loopexit_crit_edge.i.8

..loopexit_crit_edge.i.8:                         ; preds = %.lr.ph.i.3.split, %..loopexit_crit_edge.i.8.unr-lcssa
  %215 = add i64 %freePageCount.promoted.i.2, %181
  store i64 %215, i64* @freePageCount, align 8, !tbaa !8
  %.pre = load i32, i32* %18, align 4, !tbaa !11
  br label %MemMan_MarkFree.exit

MemMan_MarkFree.exit:                             ; preds = %161, %..loopexit_crit_edge.i.8, %177
  %216 = phi i32 [ %162, %161 ], [ %.pre, %..loopexit_crit_edge.i.8 ], [ %162, %177 ]
  %217 = add i32 %j.036, 1
  %218 = zext i32 %217 to i64
  %div = udiv i32 %216, 24
  %219 = icmp ult i32 %217, %div
  br i1 %219, label %161, label %._crit_edge.loopexit
}

; Function Attrs: noredzone
declare %struct.CardinalBootInfo* @GetBootInfo() #1

; Function Attrs: noredzone
declare i8* @bootstrap_malloc(i64) #1

; Function Attrs: noredzone
declare i8* @memset(i8*, i32, i64) #1

; Function Attrs: noredzone nounwind uwtable
define void @MemMan_MarkFree(i64 %addr, i64 %size) #0 {
  %1 = icmp eq i64 %size, 0
  br i1 %1, label %.loopexit, label %2

; <label>:2                                       ; preds = %0
  %3 = and i64 %size, 4095
  %4 = icmp eq i64 %3, 0
  %5 = add i64 %size, 4096
  %.0 = select i1 %4, i64 %size, i64 %5
  %6 = lshr i64 %.0, 12
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %.loopexit, label %.lr.ph

.lr.ph:                                           ; preds = %2
  %8 = and i64 %addr, -4096
  %9 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted = load i64, i64* @freePageCount, align 8, !tbaa !8
  %10 = lshr i64 %.0, 12
  %xtraiter = and i64 %10, 1
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.split, label %11

; <label>:11                                      ; preds = %.lr.ph
  %12 = lshr i64 %addr, 12
  %.tr.i.prol = trunc i64 %12 to i32
  %13 = and i32 %.tr.i.prol, 31
  %14 = shl i32 1, %13
  %15 = xor i32 %14, -1
  %16 = lshr i64 %addr, 17
  %17 = getelementptr inbounds i32, i32* %9, i64 %16
  %18 = load i32, i32* %17, align 4, !tbaa !9
  %19 = and i32 %18, %15
  store i32 %19, i32* %17, align 4, !tbaa !9
  %20 = add i64 %8, 4096
  br label %.lr.ph.split

.lr.ph.split:                                     ; preds = %.lr.ph, %11
  %i.03.unr = phi i64 [ 0, %.lr.ph ], [ 1, %11 ]
  %.012.unr = phi i64 [ %8, %.lr.ph ], [ %20, %11 ]
  %21 = icmp eq i64 %10, 1
  br i1 %21, label %..loopexit_crit_edge, label %.lr.ph.split.split

.lr.ph.split.split:                               ; preds = %.lr.ph.split
  br label %22

; <label>:22                                      ; preds = %22, %.lr.ph.split.split
  %i.03 = phi i64 [ %i.03.unr, %.lr.ph.split.split ], [ %41, %22 ]
  %.012 = phi i64 [ %.012.unr, %.lr.ph.split.split ], [ %40, %22 ]
  %23 = lshr i64 %.012, 12
  %.tr.i = trunc i64 %23 to i32
  %24 = and i32 %.tr.i, 31
  %25 = shl i32 1, %24
  %26 = xor i32 %25, -1
  %27 = lshr i64 %.012, 17
  %28 = getelementptr inbounds i32, i32* %9, i64 %27
  %29 = load i32, i32* %28, align 4, !tbaa !9
  %30 = and i32 %29, %26
  store i32 %30, i32* %28, align 4, !tbaa !9
  %31 = add i64 %.012, 4096
  %32 = lshr i64 %31, 12
  %.tr.i.1 = trunc i64 %32 to i32
  %33 = and i32 %.tr.i.1, 31
  %34 = shl i32 1, %33
  %35 = xor i32 %34, -1
  %36 = lshr i64 %31, 17
  %37 = getelementptr inbounds i32, i32* %9, i64 %36
  %38 = load i32, i32* %37, align 4, !tbaa !9
  %39 = and i32 %38, %35
  store i32 %39, i32* %37, align 4, !tbaa !9
  %40 = add i64 %.012, 8192
  %41 = add nsw i64 %i.03, 2
  %exitcond.1 = icmp eq i64 %41, %6
  br i1 %exitcond.1, label %..loopexit_crit_edge.unr-lcssa, label %22

..loopexit_crit_edge.unr-lcssa:                   ; preds = %22
  br label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %.lr.ph.split, %..loopexit_crit_edge.unr-lcssa
  %42 = add i64 %freePageCount.promoted, %6
  store i64 %42, i64* @freePageCount, align 8, !tbaa !8
  br label %.loopexit

.loopexit:                                        ; preds = %..loopexit_crit_edge, %2, %0
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define void @MemMan_MarkUsed(i64 %addr, i64 %size) #0 {
  %1 = icmp eq i64 %size, 0
  br i1 %1, label %.loopexit, label %2

; <label>:2                                       ; preds = %0
  %3 = and i64 %size, 4095
  %4 = icmp eq i64 %3, 0
  %5 = add i64 %size, 4096
  %.0 = select i1 %4, i64 %size, i64 %5
  %6 = lshr i64 %.0, 12
  %7 = icmp eq i64 %6, 0
  br i1 %7, label %.loopexit, label %.lr.ph

.lr.ph:                                           ; preds = %2
  %8 = and i64 %addr, -4096
  %9 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted = load i64, i64* @freePageCount, align 8, !tbaa !8
  %10 = lshr i64 %.0, 12
  %xtraiter = and i64 %10, 1
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.split, label %11

; <label>:11                                      ; preds = %.lr.ph
  %12 = lshr i64 %addr, 12
  %.tr.i.prol = trunc i64 %12 to i32
  %13 = and i32 %.tr.i.prol, 31
  %14 = shl i32 1, %13
  %15 = lshr i64 %addr, 17
  %16 = getelementptr inbounds i32, i32* %9, i64 %15
  %17 = load i32, i32* %16, align 4, !tbaa !9
  %18 = or i32 %17, %14
  store i32 %18, i32* %16, align 4, !tbaa !9
  %19 = add i64 %8, 4096
  br label %.lr.ph.split

.lr.ph.split:                                     ; preds = %.lr.ph, %11
  %i.03.unr = phi i64 [ 0, %.lr.ph ], [ 1, %11 ]
  %.012.unr = phi i64 [ %8, %.lr.ph ], [ %19, %11 ]
  %20 = icmp eq i64 %10, 1
  br i1 %20, label %..loopexit_crit_edge, label %.lr.ph.split.split

.lr.ph.split.split:                               ; preds = %.lr.ph.split
  br label %21

; <label>:21                                      ; preds = %21, %.lr.ph.split.split
  %i.03 = phi i64 [ %i.03.unr, %.lr.ph.split.split ], [ %38, %21 ]
  %.012 = phi i64 [ %.012.unr, %.lr.ph.split.split ], [ %37, %21 ]
  %22 = lshr i64 %.012, 12
  %.tr.i = trunc i64 %22 to i32
  %23 = and i32 %.tr.i, 31
  %24 = shl i32 1, %23
  %25 = lshr i64 %.012, 17
  %26 = getelementptr inbounds i32, i32* %9, i64 %25
  %27 = load i32, i32* %26, align 4, !tbaa !9
  %28 = or i32 %27, %24
  store i32 %28, i32* %26, align 4, !tbaa !9
  %29 = add i64 %.012, 4096
  %30 = lshr i64 %29, 12
  %.tr.i.1 = trunc i64 %30 to i32
  %31 = and i32 %.tr.i.1, 31
  %32 = shl i32 1, %31
  %33 = lshr i64 %29, 17
  %34 = getelementptr inbounds i32, i32* %9, i64 %33
  %35 = load i32, i32* %34, align 4, !tbaa !9
  %36 = or i32 %35, %32
  store i32 %36, i32* %34, align 4, !tbaa !9
  %37 = add i64 %.012, 8192
  %38 = add nsw i64 %i.03, 2
  %exitcond.1 = icmp eq i64 %38, %6
  br i1 %exitcond.1, label %..loopexit_crit_edge.unr-lcssa, label %21

..loopexit_crit_edge.unr-lcssa:                   ; preds = %21
  br label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %.lr.ph.split, %..loopexit_crit_edge.unr-lcssa
  %39 = sub i64 %freePageCount.promoted, %6
  store i64 %39, i64* @freePageCount, align 8, !tbaa !8
  br label %.loopexit

.loopexit:                                        ; preds = %..loopexit_crit_edge, %2, %0
  ret void
}

; Function Attrs: noredzone
declare i8* @GetPhysicalAddress(i8*) #1

; Function Attrs: noredzone nounwind uwtable
define i64 @MemMan_Alloc() #0 {
  %1 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %2 = icmp eq i64 %1, 0
  br i1 %2, label %.loopexit, label %.preheader2

.preheader2:                                      ; preds = %0
  %3 = load i64, i64* @lastNonFullPage, align 8, !tbaa !8
  %4 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %5 = getelementptr inbounds i32, i32* %4, i64 %3
  %6 = load i32, i32* %5, align 4, !tbaa !9
  %7 = icmp eq i32 %6, -1
  br i1 %7, label %.lr.ph, label %.preheader

.lr.ph:                                           ; preds = %.preheader2
  %8 = load i64, i64* @page_count, align 8, !tbaa !8
  br label %10

..preheader_crit_edge:                            ; preds = %10
  %.lcssa19 = phi i32 [ %15, %10 ]
  %.lcssa18 = phi i64 [ %13, %10 ]
  store i64 %.lcssa18, i64* @lastNonFullPage, align 8, !tbaa !8
  br label %.preheader

.preheader:                                       ; preds = %..preheader_crit_edge, %.preheader2
  %9 = phi i64 [ %.lcssa18, %..preheader_crit_edge ], [ %3, %.preheader2 ]
  %.lcssa = phi i32 [ %.lcssa19, %..preheader_crit_edge ], [ %6, %.preheader2 ]
  br label %17

; <label>:10                                      ; preds = %.lr.ph, %10
  %11 = phi i64 [ %3, %.lr.ph ], [ %13, %10 ]
  %12 = add i64 %11, 1
  %13 = urem i64 %12, %8
  %14 = getelementptr inbounds i32, i32* %4, i64 %13
  %15 = load i32, i32* %14, align 4, !tbaa !9
  %16 = icmp eq i32 %15, -1
  br i1 %16, label %10, label %..preheader_crit_edge

; <label>:17                                      ; preds = %49, %.preheader
  %i.04 = phi i32 [ 0, %.preheader ], [ %50, %49 ]
  %18 = shl i32 1, %i.04
  %19 = and i32 %18, %.lcssa
  %20 = icmp eq i32 %19, 0
  br i1 %20, label %21, label %34

; <label>:21                                      ; preds = %44, %39, %34, %17
  %i.04.lcssa = phi i32 [ %i.04, %17 ], [ %35, %34 ], [ %40, %39 ], [ %45, %44 ]
  %22 = shl i64 %9, 17
  %23 = sext i32 %i.04.lcssa to i64
  %24 = shl nsw i64 %23, 12
  %25 = add i64 %22, %24
  %26 = lshr exact i64 %25, 12
  %.tr.i = trunc i64 %26 to i32
  %27 = and i32 %.tr.i, 31
  %28 = shl i32 1, %27
  %29 = lshr i64 %25, 17
  %30 = getelementptr inbounds i32, i32* %4, i64 %29
  %31 = load i32, i32* %30, align 4, !tbaa !9
  %32 = or i32 %28, %31
  store i32 %32, i32* %30, align 4, !tbaa !9
  %33 = add i64 %1, -1
  store i64 %33, i64* @freePageCount, align 8, !tbaa !8
  br label %.loopexit

; <label>:34                                      ; preds = %17
  %35 = or i32 %i.04, 1
  %36 = shl i32 1, %35
  %37 = and i32 %36, %.lcssa
  %38 = icmp eq i32 %37, 0
  br i1 %38, label %21, label %39

.loopexit.loopexit:                               ; preds = %49
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %21, %0
  %.2 = phi i64 [ 0, %0 ], [ %25, %21 ], [ -1, %.loopexit.loopexit ]
  ret i64 %.2

; <label>:39                                      ; preds = %34
  %40 = or i32 %i.04, 2
  %41 = shl i32 1, %40
  %42 = and i32 %41, %.lcssa
  %43 = icmp eq i32 %42, 0
  br i1 %43, label %21, label %44

; <label>:44                                      ; preds = %39
  %45 = or i32 %i.04, 3
  %46 = shl i32 1, %45
  %47 = and i32 %46, %.lcssa
  %48 = icmp eq i32 %47, 0
  br i1 %48, label %21, label %49

; <label>:49                                      ; preds = %44
  %50 = add nsw i32 %i.04, 4
  %51 = icmp slt i32 %50, 32
  br i1 %51, label %17, label %.loopexit.loopexit
}

; Function Attrs: noredzone nounwind uwtable
define i64 @MemMan_Alloc2MiBPage() #0 {
  %1 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %2 = icmp eq i64 %1, 0
  br i1 %2, label %MemMan_Alloc4KiBPageCont.exit, label %.preheader.i

.preheader.i:                                     ; preds = %0
  %3 = load i32, i32* @KB4_Blocks_Count, align 4, !tbaa !9
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %MemMan_Alloc4KiBPageCont.exit, label %.lr.ph9.i

.lr.ph9.i:                                        ; preds = %.preheader.i
  %5 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %6 = zext i32 %3 to i64
  br label %8

._crit_edge.10.i:                                 ; preds = %._crit_edge.i
  %score.1.lcssa.i.lcssa = phi i32 [ %score.1.lcssa.i, %._crit_edge.i ]
  %addr.1.lcssa.i.lcssa = phi i64 [ %addr.1.lcssa.i, %._crit_edge.i ]
  %7 = icmp eq i32 %score.1.lcssa.i.lcssa, 512
  br i1 %7, label %26, label %MemMan_Alloc4KiBPageCont.exit

; <label>:8                                       ; preds = %._crit_edge.i, %.lr.ph9.i
  %indvars.iv13.i = phi i64 [ 0, %.lr.ph9.i ], [ %indvars.iv.next14.i, %._crit_edge.i ]
  %addr.07.i = phi i64 [ 0, %.lr.ph9.i ], [ %addr.1.lcssa.i, %._crit_edge.i ]
  %score.06.i = phi i32 [ 0, %.lr.ph9.i ], [ %score.1.lcssa.i, %._crit_edge.i ]
  %9 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv13.i
  %10 = load i32, i32* %9, align 4, !tbaa !9
  %11 = icmp eq i32 %score.06.i, 512
  br i1 %11, label %._crit_edge.i, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %8
  %12 = shl nuw nsw i64 %indvars.iv13.i, 17
  br label %13

; <label>:13                                      ; preds = %23, %.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i, %23 ]
  %addr.13.i = phi i64 [ %addr.07.i, %.lr.ph.i ], [ %addr.3.i, %23 ]
  %score.12.i = phi i32 [ %score.06.i, %.lr.ph.i ], [ %score.2.i, %23 ]
  %14 = trunc i64 %indvars.iv.i to i32
  %15 = shl i32 1, %14
  %16 = and i32 %15, %10
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %23

; <label>:18                                      ; preds = %13
  %19 = icmp eq i32 %score.12.i, 0
  %20 = shl i64 %indvars.iv.i, 12
  %21 = add nuw nsw i64 %20, %12
  %addr.2.i = select i1 %19, i64 %21, i64 %addr.13.i
  %22 = add nsw i32 %score.12.i, 1
  br label %23

; <label>:23                                      ; preds = %18, %13
  %score.2.i = phi i32 [ %22, %18 ], [ 0, %13 ]
  %addr.3.i = phi i64 [ %addr.2.i, %18 ], [ %addr.13.i, %13 ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %24 = icmp sgt i64 %indvars.iv.i, 30
  %25 = icmp eq i32 %score.2.i, 512
  %or.cond.i = or i1 %24, %25
  br i1 %or.cond.i, label %._crit_edge.i.loopexit, label %13

._crit_edge.i.loopexit:                           ; preds = %23
  %addr.3.i.lcssa = phi i64 [ %addr.3.i, %23 ]
  %score.2.i.lcssa = phi i32 [ %score.2.i, %23 ]
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i.loopexit, %8
  %addr.1.lcssa.i = phi i64 [ %addr.07.i, %8 ], [ %addr.3.i.lcssa, %._crit_edge.i.loopexit ]
  %score.1.lcssa.i = phi i32 [ 512, %8 ], [ %score.2.i.lcssa, %._crit_edge.i.loopexit ]
  %indvars.iv.next14.i = add nuw nsw i64 %indvars.iv13.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next14.i, %6
  br i1 %exitcond, label %._crit_edge.10.i, label %8

; <label>:26                                      ; preds = %._crit_edge.10.i
  %27 = and i64 %addr.1.lcssa.i.lcssa, -4096
  br label %28

; <label>:28                                      ; preds = %28, %26
  %i.03.i.i = phi i64 [ 0, %26 ], [ %45, %28 ]
  %.012.i.i = phi i64 [ %27, %26 ], [ %44, %28 ]
  %29 = lshr i64 %.012.i.i, 12
  %.tr.i.i.i = trunc i64 %29 to i32
  %30 = and i32 %.tr.i.i.i, 31
  %31 = shl i32 1, %30
  %32 = lshr i64 %.012.i.i, 17
  %33 = getelementptr inbounds i32, i32* %5, i64 %32
  %34 = load i32, i32* %33, align 4, !tbaa !9
  %35 = or i32 %31, %34
  store i32 %35, i32* %33, align 4, !tbaa !9
  %36 = add i64 %.012.i.i, 4096
  %37 = lshr i64 %36, 12
  %.tr.i.i.i.1 = trunc i64 %37 to i32
  %38 = and i32 %.tr.i.i.i.1, 31
  %39 = shl i32 1, %38
  %40 = lshr i64 %36, 17
  %41 = getelementptr inbounds i32, i32* %5, i64 %40
  %42 = load i32, i32* %41, align 4, !tbaa !9
  %43 = or i32 %39, %42
  store i32 %43, i32* %41, align 4, !tbaa !9
  %44 = add i64 %.012.i.i, 8192
  %45 = add nsw i64 %i.03.i.i, 2
  %exitcond.i.i.1 = icmp eq i64 %45, 512
  br i1 %exitcond.i.i.1, label %..loopexit_crit_edge.i.i, label %28

..loopexit_crit_edge.i.i:                         ; preds = %28
  %46 = add i64 %1, -512
  store i64 %46, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_Alloc4KiBPageCont.exit

MemMan_Alloc4KiBPageCont.exit:                    ; preds = %.preheader.i, %0, %._crit_edge.10.i, %..loopexit_crit_edge.i.i
  %.1.i = phi i64 [ 0, %0 ], [ 0, %._crit_edge.10.i ], [ %addr.1.lcssa.i.lcssa, %..loopexit_crit_edge.i.i ], [ 0, %.preheader.i ]
  ret i64 %.1.i
}

; Function Attrs: noredzone nounwind uwtable
define i64 @MemMan_Alloc4KiBPageCont(i32 %pageCount) #0 {
  %1 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %2 = icmp eq i64 %1, 0
  br i1 %2, label %MemMan_MarkUsed.exit, label %.preheader

.preheader:                                       ; preds = %0
  %3 = load i32, i32* @KB4_Blocks_Count, align 4, !tbaa !9
  %4 = icmp eq i32 %3, 0
  br i1 %4, label %._crit_edge.10, label %.lr.ph9

.lr.ph9:                                          ; preds = %.preheader
  %5 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %6 = zext i32 %3 to i64
  br label %8

._crit_edge.10.loopexit:                          ; preds = %._crit_edge
  %score.1.lcssa.lcssa = phi i32 [ %score.1.lcssa, %._crit_edge ]
  %addr.1.lcssa.lcssa = phi i64 [ %addr.1.lcssa, %._crit_edge ]
  br label %._crit_edge.10

._crit_edge.10:                                   ; preds = %._crit_edge.10.loopexit, %.preheader
  %addr.0.lcssa = phi i64 [ 0, %.preheader ], [ %addr.1.lcssa.lcssa, %._crit_edge.10.loopexit ]
  %score.0.lcssa = phi i32 [ 0, %.preheader ], [ %score.1.lcssa.lcssa, %._crit_edge.10.loopexit ]
  %7 = icmp eq i32 %score.0.lcssa, %pageCount
  br i1 %7, label %27, label %MemMan_MarkUsed.exit

; <label>:8                                       ; preds = %.lr.ph9, %._crit_edge
  %indvars.iv13 = phi i64 [ 0, %.lr.ph9 ], [ %indvars.iv.next14, %._crit_edge ]
  %addr.07 = phi i64 [ 0, %.lr.ph9 ], [ %addr.1.lcssa, %._crit_edge ]
  %score.06 = phi i32 [ 0, %.lr.ph9 ], [ %score.1.lcssa, %._crit_edge ]
  %9 = getelementptr inbounds i32, i32* %5, i64 %indvars.iv13
  %10 = load i32, i32* %9, align 4, !tbaa !9
  %11 = icmp eq i32 %score.06, %pageCount
  br i1 %11, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %8
  %12 = shl nuw nsw i64 %indvars.iv13, 17
  br label %13

; <label>:13                                      ; preds = %.lr.ph, %23
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %23 ]
  %addr.13 = phi i64 [ %addr.07, %.lr.ph ], [ %addr.3, %23 ]
  %score.12 = phi i32 [ %score.06, %.lr.ph ], [ %score.2, %23 ]
  %14 = trunc i64 %indvars.iv to i32
  %15 = shl i32 1, %14
  %16 = and i32 %15, %10
  %17 = icmp eq i32 %16, 0
  br i1 %17, label %18, label %23

; <label>:18                                      ; preds = %13
  %19 = icmp eq i32 %score.12, 0
  %20 = shl nsw i64 %indvars.iv, 12
  %21 = add nuw nsw i64 %20, %12
  %addr.2 = select i1 %19, i64 %21, i64 %addr.13
  %22 = add nsw i32 %score.12, 1
  br label %23

; <label>:23                                      ; preds = %13, %18
  %score.2 = phi i32 [ %22, %18 ], [ 0, %13 ]
  %addr.3 = phi i64 [ %addr.2, %18 ], [ %addr.13, %13 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %24 = icmp sgt i64 %indvars.iv, 30
  %25 = icmp eq i32 %score.2, %pageCount
  %or.cond = or i1 %25, %24
  br i1 %or.cond, label %._crit_edge.loopexit, label %13

._crit_edge.loopexit:                             ; preds = %23
  %addr.3.lcssa = phi i64 [ %addr.3, %23 ]
  %score.2.lcssa = phi i32 [ %score.2, %23 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %8
  %addr.1.lcssa = phi i64 [ %addr.07, %8 ], [ %addr.3.lcssa, %._crit_edge.loopexit ]
  %score.1.lcssa = phi i32 [ %pageCount, %8 ], [ %score.2.lcssa, %._crit_edge.loopexit ]
  %indvars.iv.next14 = add nuw nsw i64 %indvars.iv13, 1
  %26 = icmp ult i64 %indvars.iv.next14, %6
  br i1 %26, label %8, label %._crit_edge.10.loopexit

; <label>:27                                      ; preds = %._crit_edge.10
  %28 = icmp eq i32 %pageCount, 0
  br i1 %28, label %MemMan_MarkUsed.exit, label %29

; <label>:29                                      ; preds = %27
  %30 = sext i32 %pageCount to i64
  %31 = and i64 %30, 4503599627370495
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %MemMan_MarkUsed.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %29
  %33 = and i64 %addr.0.lcssa, -4096
  %34 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %35 = sext i32 %pageCount to i64
  %36 = and i64 %35, 4503599627370495
  %xtraiter = and i64 %35, 1
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.i.split, label %37

; <label>:37                                      ; preds = %.lr.ph.i
  %38 = lshr i64 %addr.0.lcssa, 12
  %.tr.i.i.prol = trunc i64 %38 to i32
  %39 = and i32 %.tr.i.i.prol, 31
  %40 = shl i32 1, %39
  %41 = lshr i64 %addr.0.lcssa, 17
  %42 = getelementptr inbounds i32, i32* %34, i64 %41
  %43 = load i32, i32* %42, align 4, !tbaa !9
  %44 = or i32 %40, %43
  store i32 %44, i32* %42, align 4, !tbaa !9
  %45 = add i64 %33, 4096
  br label %.lr.ph.i.split

.lr.ph.i.split:                                   ; preds = %.lr.ph.i, %37
  %i.03.i.unr = phi i64 [ 0, %.lr.ph.i ], [ 1, %37 ]
  %.012.i.unr = phi i64 [ %33, %.lr.ph.i ], [ %45, %37 ]
  %46 = icmp eq i64 %36, 1
  br i1 %46, label %..loopexit_crit_edge.i, label %.lr.ph.i.split.split

.lr.ph.i.split.split:                             ; preds = %.lr.ph.i.split
  br label %47

; <label>:47                                      ; preds = %47, %.lr.ph.i.split.split
  %i.03.i = phi i64 [ %i.03.i.unr, %.lr.ph.i.split.split ], [ %64, %47 ]
  %.012.i = phi i64 [ %.012.i.unr, %.lr.ph.i.split.split ], [ %63, %47 ]
  %48 = lshr i64 %.012.i, 12
  %.tr.i.i = trunc i64 %48 to i32
  %49 = and i32 %.tr.i.i, 31
  %50 = shl i32 1, %49
  %51 = lshr i64 %.012.i, 17
  %52 = getelementptr inbounds i32, i32* %34, i64 %51
  %53 = load i32, i32* %52, align 4, !tbaa !9
  %54 = or i32 %50, %53
  store i32 %54, i32* %52, align 4, !tbaa !9
  %55 = add i64 %.012.i, 4096
  %56 = lshr i64 %55, 12
  %.tr.i.i.1 = trunc i64 %56 to i32
  %57 = and i32 %.tr.i.i.1, 31
  %58 = shl i32 1, %57
  %59 = lshr i64 %55, 17
  %60 = getelementptr inbounds i32, i32* %34, i64 %59
  %61 = load i32, i32* %60, align 4, !tbaa !9
  %62 = or i32 %58, %61
  store i32 %62, i32* %60, align 4, !tbaa !9
  %63 = add i64 %.012.i, 8192
  %64 = add nsw i64 %i.03.i, 2
  %exitcond.i.1 = icmp eq i64 %64, %31
  br i1 %exitcond.i.1, label %..loopexit_crit_edge.i.unr-lcssa, label %47

..loopexit_crit_edge.i.unr-lcssa:                 ; preds = %47
  br label %..loopexit_crit_edge.i

..loopexit_crit_edge.i:                           ; preds = %.lr.ph.i.split, %..loopexit_crit_edge.i.unr-lcssa
  %65 = sub i64 %1, %31
  store i64 %65, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_MarkUsed.exit

MemMan_MarkUsed.exit:                             ; preds = %..loopexit_crit_edge.i, %29, %27, %._crit_edge.10, %0
  %.1 = phi i64 [ 0, %0 ], [ 0, %._crit_edge.10 ], [ %addr.0.lcssa, %27 ], [ %addr.0.lcssa, %29 ], [ %addr.0.lcssa, %..loopexit_crit_edge.i ]
  ret i64 %.1
}

; Function Attrs: noredzone nounwind uwtable
define i64 @MemMan_Alloc2MiBPageCont(i32 %pageCount) #0 {
  %1 = shl i32 %pageCount, 9
  %2 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %3 = icmp eq i64 %2, 0
  br i1 %3, label %MemMan_Alloc4KiBPageCont.exit, label %.preheader.i

.preheader.i:                                     ; preds = %0
  %4 = load i32, i32* @KB4_Blocks_Count, align 4, !tbaa !9
  %5 = icmp eq i32 %4, 0
  br i1 %5, label %._crit_edge.10.i, label %.lr.ph9.i

.lr.ph9.i:                                        ; preds = %.preheader.i
  %6 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %7 = zext i32 %4 to i64
  br label %9

._crit_edge.10.i.loopexit:                        ; preds = %._crit_edge.i
  %score.1.lcssa.i.lcssa = phi i32 [ %score.1.lcssa.i, %._crit_edge.i ]
  %addr.1.lcssa.i.lcssa = phi i64 [ %addr.1.lcssa.i, %._crit_edge.i ]
  br label %._crit_edge.10.i

._crit_edge.10.i:                                 ; preds = %._crit_edge.10.i.loopexit, %.preheader.i
  %addr.0.lcssa.i = phi i64 [ 0, %.preheader.i ], [ %addr.1.lcssa.i.lcssa, %._crit_edge.10.i.loopexit ]
  %score.0.lcssa.i = phi i32 [ 0, %.preheader.i ], [ %score.1.lcssa.i.lcssa, %._crit_edge.10.i.loopexit ]
  %8 = icmp eq i32 %score.0.lcssa.i, %1
  br i1 %8, label %27, label %MemMan_Alloc4KiBPageCont.exit

; <label>:9                                       ; preds = %._crit_edge.i, %.lr.ph9.i
  %indvars.iv13.i = phi i64 [ 0, %.lr.ph9.i ], [ %indvars.iv.next14.i, %._crit_edge.i ]
  %addr.07.i = phi i64 [ 0, %.lr.ph9.i ], [ %addr.1.lcssa.i, %._crit_edge.i ]
  %score.06.i = phi i32 [ 0, %.lr.ph9.i ], [ %score.1.lcssa.i, %._crit_edge.i ]
  %10 = getelementptr inbounds i32, i32* %6, i64 %indvars.iv13.i
  %11 = load i32, i32* %10, align 4, !tbaa !9
  %12 = icmp eq i32 %score.06.i, %1
  br i1 %12, label %._crit_edge.i, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %9
  %13 = shl nuw nsw i64 %indvars.iv13.i, 17
  br label %14

; <label>:14                                      ; preds = %24, %.lr.ph.i
  %indvars.iv.i = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i, %24 ]
  %addr.13.i = phi i64 [ %addr.07.i, %.lr.ph.i ], [ %addr.3.i, %24 ]
  %score.12.i = phi i32 [ %score.06.i, %.lr.ph.i ], [ %score.2.i, %24 ]
  %15 = trunc i64 %indvars.iv.i to i32
  %16 = shl i32 1, %15
  %17 = and i32 %16, %11
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %19, label %24

; <label>:19                                      ; preds = %14
  %20 = icmp eq i32 %score.12.i, 0
  %21 = shl i64 %indvars.iv.i, 12
  %22 = add nuw nsw i64 %21, %13
  %addr.2.i = select i1 %20, i64 %22, i64 %addr.13.i
  %23 = add nsw i32 %score.12.i, 1
  br label %24

; <label>:24                                      ; preds = %19, %14
  %score.2.i = phi i32 [ %23, %19 ], [ 0, %14 ]
  %addr.3.i = phi i64 [ %addr.2.i, %19 ], [ %addr.13.i, %14 ]
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %25 = icmp sgt i64 %indvars.iv.i, 30
  %26 = icmp eq i32 %score.2.i, %1
  %or.cond.i = or i1 %25, %26
  br i1 %or.cond.i, label %._crit_edge.i.loopexit, label %14

._crit_edge.i.loopexit:                           ; preds = %24
  %addr.3.i.lcssa = phi i64 [ %addr.3.i, %24 ]
  %score.2.i.lcssa = phi i32 [ %score.2.i, %24 ]
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %._crit_edge.i.loopexit, %9
  %addr.1.lcssa.i = phi i64 [ %addr.07.i, %9 ], [ %addr.3.i.lcssa, %._crit_edge.i.loopexit ]
  %score.1.lcssa.i = phi i32 [ %1, %9 ], [ %score.2.i.lcssa, %._crit_edge.i.loopexit ]
  %indvars.iv.next14.i = add nuw nsw i64 %indvars.iv13.i, 1
  %exitcond = icmp eq i64 %indvars.iv.next14.i, %7
  br i1 %exitcond, label %._crit_edge.10.i.loopexit, label %9

; <label>:27                                      ; preds = %._crit_edge.10.i
  %28 = icmp eq i32 %1, 0
  br i1 %28, label %MemMan_Alloc4KiBPageCont.exit, label %29

; <label>:29                                      ; preds = %27
  %30 = sext i32 %1 to i64
  %31 = and i64 %30, 4503599627369984
  %32 = icmp eq i64 %31, 0
  br i1 %32, label %MemMan_Alloc4KiBPageCont.exit, label %.lr.ph.i.i

.lr.ph.i.i:                                       ; preds = %29
  %33 = and i64 %addr.0.lcssa.i, -4096
  %34 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  br i1 false, label %35, label %.lr.ph.i.i.split

; <label>:35                                      ; preds = %.lr.ph.i.i
  br label %.lr.ph.i.i.split

.lr.ph.i.i.split:                                 ; preds = %35, %.lr.ph.i.i
  %i.03.i.i.unr = phi i64 [ 0, %.lr.ph.i.i ], [ 1, %35 ]
  br i1 false, label %..loopexit_crit_edge.i.i, label %.lr.ph.i.i.split.split

.lr.ph.i.i.split.split:                           ; preds = %.lr.ph.i.i.split
  br label %36

; <label>:36                                      ; preds = %36, %.lr.ph.i.i.split.split
  %i.03.i.i = phi i64 [ %i.03.i.i.unr, %.lr.ph.i.i.split.split ], [ %53, %36 ]
  %.012.i.i = phi i64 [ %33, %.lr.ph.i.i.split.split ], [ %52, %36 ]
  %37 = lshr i64 %.012.i.i, 12
  %.tr.i.i.i = trunc i64 %37 to i32
  %38 = and i32 %.tr.i.i.i, 31
  %39 = shl i32 1, %38
  %40 = lshr i64 %.012.i.i, 17
  %41 = getelementptr inbounds i32, i32* %34, i64 %40
  %42 = load i32, i32* %41, align 4, !tbaa !9
  %43 = or i32 %39, %42
  store i32 %43, i32* %41, align 4, !tbaa !9
  %44 = add i64 %.012.i.i, 4096
  %45 = lshr i64 %44, 12
  %.tr.i.i.i.1 = trunc i64 %45 to i32
  %46 = and i32 %.tr.i.i.i.1, 31
  %47 = shl i32 1, %46
  %48 = lshr i64 %44, 17
  %49 = getelementptr inbounds i32, i32* %34, i64 %48
  %50 = load i32, i32* %49, align 4, !tbaa !9
  %51 = or i32 %47, %50
  store i32 %51, i32* %49, align 4, !tbaa !9
  %52 = add i64 %.012.i.i, 8192
  %53 = add nsw i64 %i.03.i.i, 2
  %exitcond.i.i.1 = icmp eq i64 %53, %31
  br i1 %exitcond.i.i.1, label %..loopexit_crit_edge.i.i.unr-lcssa, label %36

..loopexit_crit_edge.i.i.unr-lcssa:               ; preds = %36
  br label %..loopexit_crit_edge.i.i

..loopexit_crit_edge.i.i:                         ; preds = %.lr.ph.i.i.split, %..loopexit_crit_edge.i.i.unr-lcssa
  %54 = sub i64 %2, %31
  store i64 %54, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_Alloc4KiBPageCont.exit

MemMan_Alloc4KiBPageCont.exit:                    ; preds = %0, %._crit_edge.10.i, %27, %29, %..loopexit_crit_edge.i.i
  %.1.i = phi i64 [ 0, %0 ], [ 0, %._crit_edge.10.i ], [ %addr.0.lcssa.i, %27 ], [ %addr.0.lcssa.i, %29 ], [ %addr.0.lcssa.i, %..loopexit_crit_edge.i.i ]
  ret i64 %.1.i
}

; Function Attrs: noredzone nounwind uwtable
define void @MemMan_Free(i64 %ptr) #0 {
  %1 = lshr i64 %ptr, 12
  %.tr.i = trunc i64 %1 to i32
  %2 = and i32 %.tr.i, 31
  %3 = shl i32 1, %2
  %4 = xor i32 %3, -1
  %5 = lshr i64 %ptr, 17
  %6 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %7 = getelementptr inbounds i32, i32* %6, i64 %5
  %8 = load i32, i32* %7, align 4, !tbaa !9
  %9 = and i32 %8, %4
  store i32 %9, i32* %7, align 4, !tbaa !9
  %10 = load i64, i64* @freePageCount, align 8, !tbaa !8
  %11 = add i64 %10, 1
  store i64 %11, i64* @freePageCount, align 8, !tbaa !8
  store i64 %5, i64* @lastNonFullPage, align 8, !tbaa !8
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define void @MemMan_FreeCont(i64 %ptr, i32 %pageCount) #0 {
  %1 = icmp eq i32 %pageCount, 0
  br i1 %1, label %MemMan_MarkFree.exit, label %2

; <label>:2                                       ; preds = %0
  %3 = sext i32 %pageCount to i64
  %4 = and i64 %3, 4503599627370495
  %5 = icmp eq i64 %4, 0
  br i1 %5, label %MemMan_MarkFree.exit, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %2
  %6 = and i64 %ptr, -4096
  %7 = load i32*, i32** @KB4_Blocks_Bitmap, align 8, !tbaa !10
  %freePageCount.promoted.i = load i64, i64* @freePageCount, align 8, !tbaa !8
  %8 = sext i32 %pageCount to i64
  %9 = and i64 %8, 4503599627370495
  %xtraiter = and i64 %8, 1
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.i.split, label %10

; <label>:10                                      ; preds = %.lr.ph.i
  %11 = lshr i64 %ptr, 12
  %.tr.i.i.prol = trunc i64 %11 to i32
  %12 = and i32 %.tr.i.i.prol, 31
  %13 = shl i32 1, %12
  %14 = xor i32 %13, -1
  %15 = lshr i64 %ptr, 17
  %16 = getelementptr inbounds i32, i32* %7, i64 %15
  %17 = load i32, i32* %16, align 4, !tbaa !9
  %18 = and i32 %17, %14
  store i32 %18, i32* %16, align 4, !tbaa !9
  %19 = add i64 %6, 4096
  br label %.lr.ph.i.split

.lr.ph.i.split:                                   ; preds = %.lr.ph.i, %10
  %i.03.i.unr = phi i64 [ 0, %.lr.ph.i ], [ 1, %10 ]
  %.012.i.unr = phi i64 [ %6, %.lr.ph.i ], [ %19, %10 ]
  %20 = icmp eq i64 %9, 1
  br i1 %20, label %..loopexit_crit_edge.i, label %.lr.ph.i.split.split

.lr.ph.i.split.split:                             ; preds = %.lr.ph.i.split
  br label %21

; <label>:21                                      ; preds = %21, %.lr.ph.i.split.split
  %i.03.i = phi i64 [ %i.03.i.unr, %.lr.ph.i.split.split ], [ %40, %21 ]
  %.012.i = phi i64 [ %.012.i.unr, %.lr.ph.i.split.split ], [ %39, %21 ]
  %22 = lshr i64 %.012.i, 12
  %.tr.i.i = trunc i64 %22 to i32
  %23 = and i32 %.tr.i.i, 31
  %24 = shl i32 1, %23
  %25 = xor i32 %24, -1
  %26 = lshr i64 %.012.i, 17
  %27 = getelementptr inbounds i32, i32* %7, i64 %26
  %28 = load i32, i32* %27, align 4, !tbaa !9
  %29 = and i32 %28, %25
  store i32 %29, i32* %27, align 4, !tbaa !9
  %30 = add i64 %.012.i, 4096
  %31 = lshr i64 %30, 12
  %.tr.i.i.1 = trunc i64 %31 to i32
  %32 = and i32 %.tr.i.i.1, 31
  %33 = shl i32 1, %32
  %34 = xor i32 %33, -1
  %35 = lshr i64 %30, 17
  %36 = getelementptr inbounds i32, i32* %7, i64 %35
  %37 = load i32, i32* %36, align 4, !tbaa !9
  %38 = and i32 %37, %34
  store i32 %38, i32* %36, align 4, !tbaa !9
  %39 = add i64 %.012.i, 8192
  %40 = add nsw i64 %i.03.i, 2
  %exitcond.i.1 = icmp eq i64 %40, %4
  br i1 %exitcond.i.1, label %..loopexit_crit_edge.i.unr-lcssa, label %21

..loopexit_crit_edge.i.unr-lcssa:                 ; preds = %21
  br label %..loopexit_crit_edge.i

..loopexit_crit_edge.i:                           ; preds = %.lr.ph.i.split, %..loopexit_crit_edge.i.unr-lcssa
  %41 = add i64 %freePageCount.promoted.i, %4
  store i64 %41, i64* @freePageCount, align 8, !tbaa !8
  br label %MemMan_MarkFree.exit

MemMan_MarkFree.exit:                             ; preds = %0, %2, %..loopexit_crit_edge.i
  ret void
}

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nobuiltin noredzone nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !3, i64 0}
!2 = !{!"", !3, i64 0, !6, i64 8, !6, i64 12, !6, i64 16, !6, i64 20, !6, i64 24, !6, i64 28, !3, i64 32, !3, i64 40, !3, i64 48, !3, i64 56, !7, i64 64, !3, i64 72, !6, i64 80, !6, i64 84, !6, i64 88, !4, i64 92}
!3 = !{!"long", !4, i64 0}
!4 = !{!"omnipotent char", !5, i64 0}
!5 = !{!"Simple C/C++ TBAA"}
!6 = !{!"int", !4, i64 0}
!7 = !{!"any pointer", !4, i64 0}
!8 = !{!3, !3, i64 0}
!9 = !{!6, !6, i64 0}
!10 = !{!7, !7, i64 0}
!11 = !{!2, !6, i64 28}
!12 = !{!2, !7, i64 64}
!13 = !{!2, !3, i64 72}
!14 = !{!2, !6, i64 80}
!15 = !{!2, !6, i64 88}
!16 = !{!2, !3, i64 48}
!17 = !{!2, !3, i64 56}
!18 = !{!19, !3, i64 0}
!19 = !{!"", !3, i64 0, !3, i64 8, !4, i64 16}
!20 = !{!19, !3, i64 8}
!21 = !{!19, !4, i64 16}
