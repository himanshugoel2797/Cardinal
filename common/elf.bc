; ModuleID = 'common/elf.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.MemoryAllocationsMap = type { i32, i64, i64, i64, i32, i32, i64, i64, %struct.MemoryAllocationsMap* }
%struct.ElfInformation = type { i8*, i8*, i64, i64 }
%struct.Elf64_Phdr = type { i32, i32, i64, i64, i64, i64, i64, i64 }

; Function Attrs: noredzone nounwind uwtable
define i32 @VerifyElf(i8* nocapture readonly %loc, i64 %size, i8* nocapture %_64bit, i32 %limits) #0 {
  %1 = icmp ult i64 %size, 24
  br i1 %1, label %52, label %2

; <label>:2                                       ; preds = %0
  %3 = load i8, i8* %loc, align 1, !tbaa !1
  %4 = icmp eq i8 %3, 127
  br i1 %4, label %5, label %52

; <label>:5                                       ; preds = %2
  %6 = getelementptr inbounds i8, i8* %loc, i64 1
  %7 = load i8, i8* %6, align 1, !tbaa !1
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %52

; <label>:9                                       ; preds = %5
  %10 = getelementptr inbounds i8, i8* %loc, i64 2
  %11 = load i8, i8* %10, align 1, !tbaa !1
  %12 = icmp eq i8 %11, 76
  br i1 %12, label %13, label %52

; <label>:13                                      ; preds = %9
  %14 = getelementptr inbounds i8, i8* %loc, i64 3
  %15 = load i8, i8* %14, align 1, !tbaa !1
  %16 = icmp eq i8 %15, 70
  br i1 %16, label %17, label %52

; <label>:17                                      ; preds = %13
  %18 = getelementptr inbounds i8, i8* %loc, i64 4
  %19 = load i8, i8* %18, align 1, !tbaa !1
  %20 = icmp eq i8 %19, 1
  %21 = and i32 %limits, 1
  %22 = icmp ne i32 %21, 0
  %23 = xor i1 %22, %20
  br i1 %23, label %52, label %24

; <label>:24                                      ; preds = %17
  %25 = getelementptr inbounds i8, i8* %loc, i64 5
  %26 = load i8, i8* %25, align 1, !tbaa !1
  %27 = icmp eq i8 %26, 2
  %28 = and i32 %limits, 2
  %29 = icmp ne i32 %28, 0
  %30 = xor i1 %29, %27
  br i1 %30, label %52, label %31

; <label>:31                                      ; preds = %24
  %32 = getelementptr inbounds i8, i8* %loc, i64 16
  %33 = bitcast i8* %32 to i16*
  %34 = load i16, i16* %33, align 2, !tbaa !4
  %35 = icmp eq i16 %34, 0
  br i1 %35, label %52, label %36

; <label>:36                                      ; preds = %31
  %37 = getelementptr inbounds i8, i8* %loc, i64 18
  %38 = bitcast i8* %37 to i16*
  %39 = load i16, i16* %38, align 2, !tbaa !8
  %40 = icmp eq i16 %39, 0
  br i1 %40, label %52, label %41

; <label>:41                                      ; preds = %36
  %42 = getelementptr inbounds i8, i8* %loc, i64 20
  %43 = bitcast i8* %42 to i32*
  %44 = load i32, i32* %43, align 4, !tbaa !9
  %45 = icmp eq i32 %44, 1
  br i1 %45, label %46, label %52

; <label>:46                                      ; preds = %41
  %47 = getelementptr inbounds i8, i8* %loc, i64 7
  %48 = load i8, i8* %47, align 1, !tbaa !1
  switch i8 %48, label %52 [
    i8 3, label %49
    i8 0, label %49
  ]

; <label>:49                                      ; preds = %46, %46
  %50 = icmp eq i8 %19, 2
  %51 = zext i1 %50 to i8
  store i8 %51, i8* %_64bit, align 1, !tbaa !1
  br label %52

; <label>:52                                      ; preds = %2, %5, %9, %13, %46, %41, %36, %31, %24, %17, %49, %0
  %.2 = phi i32 [ 2, %0 ], [ 2, %2 ], [ 2, %5 ], [ 2, %9 ], [ 2, %13 ], [ 0, %49 ], [ 4, %17 ], [ 1, %24 ], [ 2, %31 ], [ 3, %36 ], [ 2, %41 ], [ 3, %46 ]
  ret i32 %.2
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

; Function Attrs: noredzone nounwind uwtable
define i32 @LoadElf32(i8* nocapture readnone %loc, i64 %size, i32 %UNUSED_limits, i64 %pageTable, %struct.MemoryAllocationsMap** nocapture %map, %struct.ElfInformation* nocapture readnone %elfData) #0 {
  store %struct.MemoryAllocationsMap* null, %struct.MemoryAllocationsMap** %map, align 8, !tbaa !10
  %1 = icmp ult i64 %size, 52
  %. = select i1 %1, i32 2, i32 0
  ret i32 %.
}

; Function Attrs: noredzone nounwind uwtable
define i32 @LoadElf64(i8* %loc, i64 %size, i32 %UNUSED_limits, i64 %pageTable, %struct.MemoryAllocationsMap** %map, %struct.ElfInformation* nocapture %elfData) #0 {
  %v_tmp_addr = alloca i64, align 8
  %1 = icmp ult i64 %size, 64
  br i1 %1, label %138, label %2

; <label>:2                                       ; preds = %0
  %3 = getelementptr inbounds i8, i8* %loc, i64 24
  %4 = bitcast i8* %3 to i64*
  %5 = load i64, i64* %4, align 8, !tbaa !12
  %6 = bitcast %struct.ElfInformation* %elfData to i64*
  store i64 %5, i64* %6, align 8, !tbaa !15
  %7 = getelementptr inbounds i8, i8* %loc, i64 32
  %8 = bitcast i8* %7 to i64*
  %9 = load i64, i64* %8, align 8, !tbaa !17
  %10 = ptrtoint i8* %loc to i64
  %11 = add i64 %9, %10
  %12 = inttoptr i64 %11 to i8*
  %13 = getelementptr inbounds %struct.ElfInformation, %struct.ElfInformation* %elfData, i64 0, i32 1
  store i8* %12, i8** %13, align 8, !tbaa !18
  %14 = getelementptr inbounds i8, i8* %loc, i64 56
  %15 = bitcast i8* %14 to i16*
  %16 = load i16, i16* %15, align 2, !tbaa !19
  %17 = zext i16 %16 to i64
  %18 = getelementptr inbounds %struct.ElfInformation, %struct.ElfInformation* %elfData, i64 0, i32 2
  store i64 %17, i64* %18, align 8, !tbaa !20
  %19 = getelementptr inbounds i8, i8* %loc, i64 54
  %20 = bitcast i8* %19 to i16*
  %21 = load i16, i16* %20, align 2, !tbaa !21
  %22 = zext i16 %21 to i64
  %23 = getelementptr inbounds %struct.ElfInformation, %struct.ElfInformation* %elfData, i64 0, i32 3
  store i64 %22, i64* %23, align 8, !tbaa !22
  %24 = bitcast i64* %v_tmp_addr to i8*
  call void @llvm.lifetime.start(i64 8, i8* %24) #1
  store i64 0, i64* %v_tmp_addr, align 8, !tbaa !23
  %25 = tail call i64 @GetActiveVirtualMemoryInstance() #3
  %26 = call i32 @FindFreeVirtualAddress(i64 %25, i64* nonnull %v_tmp_addr, i64 4096, i32 0, i32 4) #3
  %27 = load i16, i16* %15, align 2, !tbaa !19
  %28 = icmp eq i16 %27, 0
  br i1 %28, label %._crit_edge, label %.lr.ph11

.lr.ph11:                                         ; preds = %2
  %29 = load i64, i64* %8, align 8, !tbaa !17
  %30 = add i64 %29, %10
  %31 = icmp eq %struct.MemoryAllocationsMap** %map, null
  %32 = bitcast i64* %v_tmp_addr to i8**
  %33 = bitcast %struct.MemoryAllocationsMap** %map to i64*
  %34 = bitcast %struct.MemoryAllocationsMap** %map to i8**
  br label %35

._crit_edge.loopexit:                             ; preds = %.loopexit
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %2
  call void @llvm.lifetime.end(i64 8, i8* %24) #1
  br label %138

; <label>:35                                      ; preds = %.lr.ph11, %.loopexit
  %36 = phi i16 [ %27, %.lr.ph11 ], [ %131, %.loopexit ]
  %phdr.010.in = phi i64 [ %30, %.lr.ph11 ], [ %135, %.loopexit ]
  %i.08 = phi i32 [ 0, %.lr.ph11 ], [ %132, %.loopexit ]
  %phdr.010 = inttoptr i64 %phdr.010.in to %struct.Elf64_Phdr*
  %37 = getelementptr inbounds %struct.Elf64_Phdr, %struct.Elf64_Phdr* %phdr.010, i64 0, i32 0
  %38 = load i32, i32* %37, align 4, !tbaa !24
  %39 = icmp eq i32 %38, 1
  br i1 %39, label %40, label %.loopexit

; <label>:40                                      ; preds = %35
  %41 = getelementptr inbounds %struct.Elf64_Phdr, %struct.Elf64_Phdr* %phdr.010, i64 0, i32 1
  %42 = load i32, i32* %41, align 4, !tbaa !26
  %43 = shl i32 %42, 1
  %44 = and i32 %43, 6
  %flags.1 = or i32 %44, 8
  %45 = getelementptr inbounds %struct.Elf64_Phdr, %struct.Elf64_Phdr* %phdr.010, i64 0, i32 3
  %46 = load i64, i64* %45, align 8, !tbaa !27
  %47 = and i64 %46, 4095
  %48 = getelementptr inbounds %struct.Elf64_Phdr, %struct.Elf64_Phdr* %phdr.010, i64 0, i32 6
  %49 = load i64, i64* %48, align 8, !tbaa !28
  %50 = add i64 %47, %49
  %51 = lshr i64 %50, 12
  %52 = trunc i64 %51 to i32
  %53 = and i64 %50, 17592186040320
  %54 = icmp ult i64 %53, %50
  %55 = zext i1 %54 to i32
  %56 = getelementptr inbounds %struct.Elf64_Phdr, %struct.Elf64_Phdr* %phdr.010, i64 0, i32 5
  %57 = load i64, i64* %56, align 8, !tbaa !29
  %58 = getelementptr inbounds %struct.Elf64_Phdr, %struct.Elf64_Phdr* %phdr.010, i64 0, i32 2
  %59 = load i64, i64* %58, align 8, !tbaa !30
  %.1 = sub i32 0, %52
  %60 = icmp eq i32 %55, %.1
  br i1 %60, label %.loopexit, label %.lr.ph

.lr.ph:                                           ; preds = %40
  %61 = and i64 %46, 4095
  %62 = add i64 %49, %61
  %63 = lshr i64 %62, 12
  %64 = trunc i64 %63 to i32
  %65 = add i32 %55, %64
  br i1 %31, label %.lr.ph..lr.ph.split_crit_edge.preheader, label %.lr.ph.split.us.preheader

.lr.ph.split.us.preheader:                        ; preds = %.lr.ph
  br label %.lr.ph.split.us

.lr.ph..lr.ph.split_crit_edge.preheader:          ; preds = %.lr.ph
  br label %.lr.ph..lr.ph.split_crit_edge

.lr.ph.split.us:                                  ; preds = %.lr.ph.split.us.preheader, %87
  %j.06.us = phi i32 [ %100, %87 ], [ 0, %.lr.ph.split.us.preheader ]
  %p_offset.05.us = phi i64 [ %99, %87 ], [ %59, %.lr.ph.split.us.preheader ]
  %p_filesz.04.us = phi i64 [ %95, %87 ], [ %57, %.lr.ph.split.us.preheader ]
  %p_memsz.03.us = phi i64 [ %94, %87 ], [ %49, %.lr.ph.split.us.preheader ]
  %p_vaddr.02.us = phi i64 [ %98, %87 ], [ %46, %.lr.ph.split.us.preheader ]
  %66 = and i64 %p_vaddr.02.us, 4095
  %67 = sub nsw i64 4096, %66
  %68 = icmp ugt i64 %p_memsz.03.us, %67
  %.p_memsz.0.us = select i1 %68, i64 %67, i64 %p_memsz.03.us
  %69 = icmp ugt i64 %p_filesz.04.us, %67
  %70 = select i1 %69, i64 %67, i64 %p_filesz.04.us
  %71 = call i8* @kmalloc(i64 64) #3
  %72 = bitcast i8* %71 to %struct.MemoryAllocationsMap*
  %73 = call i64 @AllocatePhysicalPage() #3
  %74 = call i32 @MapPage(i64 %pageTable, %struct.MemoryAllocationsMap* %72, i64 %73, i64 %p_vaddr.02.us, i64 4096, i32 0, i32 64, i32 %flags.1) #3
  %75 = call i64 @GetActiveVirtualMemoryInstance() #3
  %76 = load i64, i64* %v_tmp_addr, align 8, !tbaa !23
  %77 = call i32 @MapPage(i64 %75, %struct.MemoryAllocationsMap* null, i64 %73, i64 %76, i64 4096, i32 0, i32 0, i32 4) #3
  %78 = load i32, i32* %37, align 4, !tbaa !24
  %cond.us = icmp eq i32 %78, 1
  br i1 %cond.us, label %79, label %87

; <label>:79                                      ; preds = %.lr.ph.split.us
  %80 = load i8*, i8** %32, align 8, !tbaa !23
  %81 = getelementptr i8, i8* %80, i64 %66
  %82 = call i8* @memset(i8* %81, i32 0, i64 %.p_memsz.0.us) #3
  %83 = load i8*, i8** %32, align 8, !tbaa !23
  %84 = getelementptr i8, i8* %83, i64 %66
  %85 = getelementptr inbounds i8, i8* %loc, i64 %p_offset.05.us
  %86 = call i8* @memcpy(i8* %84, i8* %85, i64 %70) #3
  br label %87

; <label>:87                                      ; preds = %79, %.lr.ph.split.us
  %88 = call i64 @GetActiveVirtualMemoryInstance() #3
  %89 = load i64, i64* %v_tmp_addr, align 8, !tbaa !23
  %90 = call i32 @UnmapPage(i64 %88, i64 %89, i64 4096) #3
  %91 = load i64, i64* %33, align 8, !tbaa !10
  %92 = getelementptr inbounds i8, i8* %71, i64 56
  %93 = bitcast i8* %92 to i64*
  store i64 %91, i64* %93, align 8, !tbaa !31
  store i8* %71, i8** %34, align 8, !tbaa !10
  %94 = sub i64 %p_memsz.03.us, %.p_memsz.0.us
  %95 = sub i64 %p_filesz.04.us, %70
  %96 = icmp ugt i64 %70, %.p_memsz.0.us
  %97 = select i1 %96, i64 %70, i64 %.p_memsz.0.us
  %98 = add i64 %97, %p_vaddr.02.us
  %99 = add i64 %70, %p_offset.05.us
  %100 = add nuw i32 %j.06.us, 1
  %exitcond12 = icmp eq i32 %100, %65
  br i1 %exitcond12, label %..loopexit_crit_edge.loopexit18, label %.lr.ph.split.us

.lr.ph..lr.ph.split_crit_edge:                    ; preds = %.lr.ph..lr.ph.split_crit_edge.preheader, %120
  %j.06 = phi i32 [ %130, %120 ], [ 0, %.lr.ph..lr.ph.split_crit_edge.preheader ]
  %p_offset.05 = phi i64 [ %129, %120 ], [ %59, %.lr.ph..lr.ph.split_crit_edge.preheader ]
  %p_filesz.04 = phi i64 [ %125, %120 ], [ %57, %.lr.ph..lr.ph.split_crit_edge.preheader ]
  %p_memsz.03 = phi i64 [ %124, %120 ], [ %49, %.lr.ph..lr.ph.split_crit_edge.preheader ]
  %p_vaddr.02 = phi i64 [ %128, %120 ], [ %46, %.lr.ph..lr.ph.split_crit_edge.preheader ]
  %101 = and i64 %p_vaddr.02, 4095
  %102 = sub nsw i64 4096, %101
  %103 = icmp ugt i64 %p_memsz.03, %102
  %.p_memsz.0 = select i1 %103, i64 %102, i64 %p_memsz.03
  %104 = icmp ugt i64 %p_filesz.04, %102
  %105 = select i1 %104, i64 %102, i64 %p_filesz.04
  %106 = call i64 @AllocatePhysicalPage() #3
  %107 = call i32 @MapPage(i64 %pageTable, %struct.MemoryAllocationsMap* null, i64 %106, i64 %p_vaddr.02, i64 4096, i32 0, i32 64, i32 %flags.1) #3
  %108 = call i64 @GetActiveVirtualMemoryInstance() #3
  %109 = load i64, i64* %v_tmp_addr, align 8, !tbaa !23
  %110 = call i32 @MapPage(i64 %108, %struct.MemoryAllocationsMap* null, i64 %106, i64 %109, i64 4096, i32 0, i32 0, i32 4) #3
  %111 = load i32, i32* %37, align 4, !tbaa !24
  %cond = icmp eq i32 %111, 1
  br i1 %cond, label %112, label %120

; <label>:112                                     ; preds = %.lr.ph..lr.ph.split_crit_edge
  %113 = load i8*, i8** %32, align 8, !tbaa !23
  %114 = getelementptr i8, i8* %113, i64 %101
  %115 = call i8* @memset(i8* %114, i32 0, i64 %.p_memsz.0) #3
  %116 = load i8*, i8** %32, align 8, !tbaa !23
  %117 = getelementptr i8, i8* %116, i64 %101
  %118 = getelementptr inbounds i8, i8* %loc, i64 %p_offset.05
  %119 = call i8* @memcpy(i8* %117, i8* %118, i64 %105) #3
  br label %120

; <label>:120                                     ; preds = %112, %.lr.ph..lr.ph.split_crit_edge
  %121 = call i64 @GetActiveVirtualMemoryInstance() #3
  %122 = load i64, i64* %v_tmp_addr, align 8, !tbaa !23
  %123 = call i32 @UnmapPage(i64 %121, i64 %122, i64 4096) #3
  %124 = sub i64 %p_memsz.03, %.p_memsz.0
  %125 = sub i64 %p_filesz.04, %105
  %126 = icmp ugt i64 %105, %.p_memsz.0
  %127 = select i1 %126, i64 %105, i64 %.p_memsz.0
  %128 = add i64 %127, %p_vaddr.02
  %129 = add i64 %105, %p_offset.05
  %130 = add nuw i32 %j.06, 1
  %exitcond = icmp eq i32 %130, %65
  br i1 %exitcond, label %..loopexit_crit_edge.loopexit, label %.lr.ph..lr.ph.split_crit_edge

..loopexit_crit_edge.loopexit:                    ; preds = %120
  br label %..loopexit_crit_edge

..loopexit_crit_edge.loopexit18:                  ; preds = %87
  br label %..loopexit_crit_edge

..loopexit_crit_edge:                             ; preds = %..loopexit_crit_edge.loopexit18, %..loopexit_crit_edge.loopexit
  %.pre.pre = load i16, i16* %15, align 2, !tbaa !19
  br label %.loopexit

.loopexit:                                        ; preds = %..loopexit_crit_edge, %40, %35
  %131 = phi i16 [ %36, %35 ], [ %36, %40 ], [ %.pre.pre, %..loopexit_crit_edge ]
  %132 = add nuw nsw i32 %i.08, 1
  %133 = load i16, i16* %20, align 2, !tbaa !21
  %134 = zext i16 %133 to i64
  %135 = add i64 %134, %phdr.010.in
  %136 = zext i16 %131 to i32
  %137 = icmp slt i32 %132, %136
  br i1 %137, label %35, label %._crit_edge.loopexit

; <label>:138                                     ; preds = %0, %._crit_edge
  %.0 = phi i32 [ 0, %._crit_edge ], [ 2, %0 ]
  ret i32 %.0
}

; Function Attrs: noredzone
declare i32 @FindFreeVirtualAddress(i64, i64*, i64, i32, i32) #2

; Function Attrs: noredzone
declare i64 @GetActiveVirtualMemoryInstance() #2

; Function Attrs: noredzone
declare i8* @kmalloc(i64) #2

; Function Attrs: noredzone
declare i64 @AllocatePhysicalPage() #2

; Function Attrs: noredzone
declare i32 @MapPage(i64, %struct.MemoryAllocationsMap*, i64, i64, i64, i32, i32, i32) #2

; Function Attrs: noredzone
declare i8* @memset(i8*, i32, i64) #2

; Function Attrs: noredzone
declare i8* @memcpy(i8*, i8*, i64) #2

; Function Attrs: noredzone
declare i32 @UnmapPage(i64, i64, i64) #2

; Function Attrs: noredzone nounwind uwtable
define i32 @LoadElf(i8* %loc, i64 %size, i32 %limits, i64 %pageTable, %struct.MemoryAllocationsMap** %map, %struct.ElfInformation* nocapture %elfData) #0 {
  %1 = icmp ult i64 %size, 24
  br i1 %1, label %VerifyElf.exit.thread, label %2

; <label>:2                                       ; preds = %0
  %3 = load i8, i8* %loc, align 1, !tbaa !1
  %4 = icmp eq i8 %3, 127
  br i1 %4, label %5, label %VerifyElf.exit.thread

; <label>:5                                       ; preds = %2
  %6 = getelementptr inbounds i8, i8* %loc, i64 1
  %7 = load i8, i8* %6, align 1, !tbaa !1
  %8 = icmp eq i8 %7, 69
  br i1 %8, label %9, label %VerifyElf.exit.thread

; <label>:9                                       ; preds = %5
  %10 = getelementptr inbounds i8, i8* %loc, i64 2
  %11 = load i8, i8* %10, align 1, !tbaa !1
  %12 = icmp eq i8 %11, 76
  br i1 %12, label %13, label %VerifyElf.exit.thread

; <label>:13                                      ; preds = %9
  %14 = getelementptr inbounds i8, i8* %loc, i64 3
  %15 = load i8, i8* %14, align 1, !tbaa !1
  %16 = icmp eq i8 %15, 70
  br i1 %16, label %17, label %VerifyElf.exit.thread

; <label>:17                                      ; preds = %13
  %18 = getelementptr inbounds i8, i8* %loc, i64 4
  %19 = load i8, i8* %18, align 1, !tbaa !1
  %20 = icmp eq i8 %19, 1
  %21 = and i32 %limits, 1
  %22 = icmp ne i32 %21, 0
  %23 = xor i1 %22, %20
  br i1 %23, label %VerifyElf.exit.thread, label %24

; <label>:24                                      ; preds = %17
  %25 = getelementptr inbounds i8, i8* %loc, i64 5
  %26 = load i8, i8* %25, align 1, !tbaa !1
  %27 = icmp eq i8 %26, 2
  %28 = and i32 %limits, 2
  %29 = icmp ne i32 %28, 0
  %30 = xor i1 %29, %27
  br i1 %30, label %VerifyElf.exit.thread, label %31

; <label>:31                                      ; preds = %24
  %32 = getelementptr inbounds i8, i8* %loc, i64 16
  %33 = bitcast i8* %32 to i16*
  %34 = load i16, i16* %33, align 2, !tbaa !4
  %35 = icmp eq i16 %34, 0
  br i1 %35, label %VerifyElf.exit.thread, label %36

; <label>:36                                      ; preds = %31
  %37 = getelementptr inbounds i8, i8* %loc, i64 18
  %38 = bitcast i8* %37 to i16*
  %39 = load i16, i16* %38, align 2, !tbaa !8
  %40 = icmp eq i16 %39, 0
  br i1 %40, label %VerifyElf.exit.thread, label %41

; <label>:41                                      ; preds = %36
  %42 = getelementptr inbounds i8, i8* %loc, i64 20
  %43 = bitcast i8* %42 to i32*
  %44 = load i32, i32* %43, align 4, !tbaa !9
  %45 = icmp eq i32 %44, 1
  br i1 %45, label %46, label %VerifyElf.exit.thread

; <label>:46                                      ; preds = %41
  %47 = getelementptr inbounds i8, i8* %loc, i64 7
  %48 = load i8, i8* %47, align 1, !tbaa !1
  switch i8 %48, label %VerifyElf.exit.thread [
    i8 3, label %49
    i8 0, label %49
  ]

; <label>:49                                      ; preds = %46, %46
  %50 = icmp eq i8 %19, 2
  br i1 %50, label %51, label %53

; <label>:51                                      ; preds = %49
  %52 = tail call i32 @LoadElf64(i8* %loc, i64 %size, i32 undef, i64 %pageTable, %struct.MemoryAllocationsMap** %map, %struct.ElfInformation* %elfData) #4
  br label %VerifyElf.exit.thread

; <label>:53                                      ; preds = %49
  store %struct.MemoryAllocationsMap* null, %struct.MemoryAllocationsMap** %map, align 8, !tbaa !10
  %54 = icmp ult i64 %size, 52
  %..i = select i1 %54, i32 2, i32 0
  br label %VerifyElf.exit.thread

VerifyElf.exit.thread:                            ; preds = %46, %41, %36, %31, %24, %17, %13, %9, %5, %2, %0, %53, %51
  %.0 = phi i32 [ %52, %51 ], [ %..i, %53 ], [ 3, %46 ], [ 2, %41 ], [ 3, %36 ], [ 2, %31 ], [ 1, %24 ], [ 4, %17 ], [ 2, %13 ], [ 2, %9 ], [ 2, %5 ], [ 2, %2 ], [ 2, %0 ]
  ret i32 %.0
}

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nobuiltin noredzone nounwind }
attributes #4 = { nobuiltin noredzone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"omnipotent char", !3, i64 0}
!3 = !{!"Simple C/C++ TBAA"}
!4 = !{!5, !6, i64 16}
!5 = !{!"", !2, i64 0, !6, i64 16, !6, i64 18, !7, i64 20}
!6 = !{!"short", !2, i64 0}
!7 = !{!"int", !2, i64 0}
!8 = !{!5, !6, i64 18}
!9 = !{!5, !7, i64 20}
!10 = !{!11, !11, i64 0}
!11 = !{!"any pointer", !2, i64 0}
!12 = !{!13, !14, i64 24}
!13 = !{!"", !5, i64 0, !14, i64 24, !14, i64 32, !14, i64 40, !7, i64 48, !6, i64 52, !6, i64 54, !6, i64 56, !6, i64 58, !6, i64 60, !6, i64 62}
!14 = !{!"long", !2, i64 0}
!15 = !{!16, !11, i64 0}
!16 = !{!"ElfInformation", !11, i64 0, !11, i64 8, !14, i64 16, !14, i64 24}
!17 = !{!13, !14, i64 32}
!18 = !{!16, !11, i64 8}
!19 = !{!13, !6, i64 56}
!20 = !{!16, !14, i64 16}
!21 = !{!13, !6, i64 54}
!22 = !{!16, !14, i64 24}
!23 = !{!14, !14, i64 0}
!24 = !{!25, !7, i64 0}
!25 = !{!"", !7, i64 0, !7, i64 4, !14, i64 8, !14, i64 16, !14, i64 24, !14, i64 32, !14, i64 40, !14, i64 48}
!26 = !{!25, !7, i64 4}
!27 = !{!25, !14, i64 16}
!28 = !{!25, !14, i64 40}
!29 = !{!25, !14, i64 32}
!30 = !{!25, !14, i64 8}
!31 = !{!32, !11, i64 56}
!32 = !{!"MemoryAllocationsMap", !2, i64 0, !14, i64 8, !14, i64 16, !14, i64 24, !2, i64 32, !2, i64 36, !14, i64 40, !14, i64 48, !11, i64 56}
