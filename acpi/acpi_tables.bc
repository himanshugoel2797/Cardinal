; ModuleID = 'acpi/acpi_tables.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.RSDPDescriptor20 = type <{ %struct.RSDPDescriptor, i32, i64, i8, [3 x i8] }>
%struct.RSDPDescriptor = type { [8 x i8], i8, [6 x i8], i8, i32 }
%struct.CardinalBootInfo = type { i64, i32, i32, i32, i32, i32, i32, i64, i64, i64, i64, %struct.CardinalMemMap*, i64, i32, i32, i32, i8 }
%struct.CardinalMemMap = type { i64, i64, i8 }
%struct.ACPISDTHeader = type { [4 x i8], i32, i8, i8, [6 x i8], [8 x i8], i32, i32, i32 }

@rsdp = internal unnamed_addr global %struct.RSDPDescriptor20* null, align 8
@.str = private unnamed_addr constant [9 x i8] c"RSD PTR \00", align 1

; Function Attrs: noredzone nounwind uwtable
define zeroext i8 @ACPITables_Initialize() #0 {
  store %struct.RSDPDescriptor20* null, %struct.RSDPDescriptor20** @rsdp, align 8, !tbaa !1
  %1 = tail call %struct.CardinalBootInfo* @GetBootInfo() #3
  %2 = getelementptr inbounds %struct.CardinalBootInfo, %struct.CardinalBootInfo* %1, i64 0, i32 8
  %3 = bitcast i64* %2 to i8**
  %4 = load i8*, i8** %3, align 8, !tbaa !5
  %5 = load i8, i8* %4, align 1, !tbaa !9
  %6 = icmp eq i8 %5, 82
  br i1 %6, label %7, label %94

; <label>:7                                       ; preds = %0
  %8 = tail call i32 @strncmp(i8* %4, i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i64 0, i64 0), i64 8) #3
  %9 = icmp eq i32 %8, 0
  br i1 %9, label %10, label %94

; <label>:10                                      ; preds = %7
  store i8* %4, i8** bitcast (%struct.RSDPDescriptor20** @rsdp to i8**), align 8, !tbaa !1
  %11 = load i8, i8* %4, align 1, !tbaa !9
  %12 = zext i8 %11 to i32
  %13 = getelementptr inbounds i8, i8* %4, i64 1
  %14 = load i8, i8* %13, align 1, !tbaa !9
  %15 = zext i8 %14 to i32
  %16 = add nuw nsw i32 %15, %12
  %17 = getelementptr inbounds i8, i8* %4, i64 2
  %18 = load i8, i8* %17, align 1, !tbaa !9
  %19 = zext i8 %18 to i32
  %20 = add nuw nsw i32 %19, %16
  %21 = getelementptr inbounds i8, i8* %4, i64 3
  %22 = load i8, i8* %21, align 1, !tbaa !9
  %23 = zext i8 %22 to i32
  %24 = add nuw nsw i32 %23, %20
  %25 = getelementptr inbounds i8, i8* %4, i64 4
  %26 = load i8, i8* %25, align 1, !tbaa !9
  %27 = zext i8 %26 to i32
  %28 = add nuw nsw i32 %27, %24
  %29 = getelementptr inbounds i8, i8* %4, i64 5
  %30 = load i8, i8* %29, align 1, !tbaa !9
  %31 = zext i8 %30 to i32
  %32 = add nuw nsw i32 %31, %28
  %33 = getelementptr inbounds i8, i8* %4, i64 6
  %34 = load i8, i8* %33, align 1, !tbaa !9
  %35 = zext i8 %34 to i32
  %36 = add nuw nsw i32 %35, %32
  %37 = getelementptr inbounds i8, i8* %4, i64 7
  %38 = load i8, i8* %37, align 1, !tbaa !9
  %39 = zext i8 %38 to i32
  %40 = add i32 %39, %36
  %41 = getelementptr inbounds i8, i8* %4, i64 8
  %42 = load i8, i8* %41, align 1, !tbaa !9
  %43 = zext i8 %42 to i32
  %44 = add i32 %43, %40
  %45 = getelementptr inbounds i8, i8* %4, i64 9
  %46 = load i8, i8* %45, align 1, !tbaa !9
  %47 = zext i8 %46 to i32
  %48 = add i32 %47, %44
  %49 = getelementptr inbounds i8, i8* %4, i64 10
  %50 = load i8, i8* %49, align 1, !tbaa !9
  %51 = zext i8 %50 to i32
  %52 = add i32 %51, %48
  %53 = getelementptr inbounds i8, i8* %4, i64 11
  %54 = load i8, i8* %53, align 1, !tbaa !9
  %55 = zext i8 %54 to i32
  %56 = add i32 %55, %52
  %57 = getelementptr inbounds i8, i8* %4, i64 12
  %58 = load i8, i8* %57, align 1, !tbaa !9
  %59 = zext i8 %58 to i32
  %60 = add i32 %59, %56
  %61 = getelementptr inbounds i8, i8* %4, i64 13
  %62 = load i8, i8* %61, align 1, !tbaa !9
  %63 = zext i8 %62 to i32
  %64 = add i32 %63, %60
  %65 = getelementptr inbounds i8, i8* %4, i64 14
  %66 = load i8, i8* %65, align 1, !tbaa !9
  %67 = zext i8 %66 to i32
  %68 = add i32 %67, %64
  %69 = getelementptr inbounds i8, i8* %4, i64 15
  %70 = load i8, i8* %69, align 1, !tbaa !9
  %71 = zext i8 %70 to i32
  %72 = add i32 %71, %68
  %73 = getelementptr inbounds i8, i8* %4, i64 16
  %74 = load i8, i8* %73, align 1, !tbaa !9
  %75 = zext i8 %74 to i32
  %76 = add i32 %75, %72
  %77 = getelementptr inbounds i8, i8* %4, i64 17
  %78 = load i8, i8* %77, align 1, !tbaa !9
  %79 = zext i8 %78 to i32
  %80 = add i32 %79, %76
  %81 = getelementptr inbounds i8, i8* %4, i64 18
  %82 = load i8, i8* %81, align 1, !tbaa !9
  %83 = zext i8 %82 to i32
  %84 = add i32 %83, %80
  %85 = getelementptr inbounds i8, i8* %4, i64 19
  %86 = load i8, i8* %85, align 1, !tbaa !9
  %87 = zext i8 %86 to i32
  %88 = add i32 %87, %84
  %89 = and i32 %88, 255
  %90 = icmp eq i32 %89, 0
  br i1 %90, label %91, label %.thread

.thread:                                          ; preds = %10
  store %struct.RSDPDescriptor20* null, %struct.RSDPDescriptor20** @rsdp, align 8, !tbaa !1
  br label %94

; <label>:91                                      ; preds = %10
  %92 = getelementptr inbounds i8, i8* %4, i64 15
  %93 = load i8, i8* %92, align 1, !tbaa !10
  br label %94

; <label>:94                                      ; preds = %0, %7, %.thread, %91
  %.1 = phi i8 [ %93, %91 ], [ -1, %.thread ], [ -1, %7 ], [ -1, %0 ]
  ret i8 %.1
}

; Function Attrs: noredzone
declare %struct.CardinalBootInfo* @GetBootInfo() #1

; Function Attrs: noredzone
declare i32 @strncmp(i8*, i8*, i64) #1

; Function Attrs: noredzone nounwind readonly uwtable
define zeroext i8 @ACPITables_ValidateChecksum(%struct.ACPISDTHeader* nocapture readonly %header) #2 {
  %1 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %header, i64 0, i32 1
  %2 = load i32, i32* %1, align 1, !tbaa !13
  %3 = icmp eq i32 %2, 0
  br i1 %3, label %13, label %.lr.ph

.lr.ph:                                           ; preds = %0
  %4 = zext i32 %2 to i64
  %5 = zext i32 %2 to i64
  %6 = add nsw i64 %5, -1
  %xtraiter = and i64 %5, 3
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.split, label %.preheader

.preheader:                                       ; preds = %.lr.ph
  br label %7

; <label>:7                                       ; preds = %.preheader, %7
  %indvars.iv.prol = phi i64 [ %indvars.iv.next.prol, %7 ], [ 0, %.preheader ]
  %sum.01.prol = phi i32 [ %phitmp.prol, %7 ], [ 0, %.preheader ]
  %prol.iter = phi i64 [ %prol.iter.sub, %7 ], [ %xtraiter, %.preheader ]
  %8 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %header, i64 0, i32 0, i64 %indvars.iv.prol
  %9 = load i8, i8* %8, align 1, !tbaa !9
  %10 = zext i8 %9 to i32
  %11 = add nuw nsw i32 %10, %sum.01.prol
  %indvars.iv.next.prol = add nuw nsw i64 %indvars.iv.prol, 1
  %phitmp.prol = and i32 %11, 255
  %prol.iter.sub = add i64 %prol.iter, -1
  %prol.iter.cmp = icmp eq i64 %prol.iter.sub, 0
  br i1 %prol.iter.cmp, label %.lr.ph.split.loopexit, label %7, !llvm.loop !15

.lr.ph.split.loopexit:                            ; preds = %7
  %phitmp.prol.lcssa = phi i32 [ %phitmp.prol, %7 ]
  %indvars.iv.next.prol.lcssa = phi i64 [ %indvars.iv.next.prol, %7 ]
  br label %.lr.ph.split

.lr.ph.split:                                     ; preds = %.lr.ph.split.loopexit, %.lr.ph
  %indvars.iv.unr = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next.prol.lcssa, %.lr.ph.split.loopexit ]
  %sum.01.unr = phi i32 [ 0, %.lr.ph ], [ %phitmp.prol.lcssa, %.lr.ph.split.loopexit ]
  %phitmp.lcssa.unr = phi i32 [ undef, %.lr.ph ], [ %phitmp.prol.lcssa, %.lr.ph.split.loopexit ]
  %12 = icmp ult i64 %6, 3
  br i1 %12, label %._crit_edge, label %.lr.ph.split.split

.lr.ph.split.split:                               ; preds = %.lr.ph.split
  br label %15

._crit_edge.unr-lcssa:                            ; preds = %15
  %phitmp.3.lcssa = phi i32 [ %phitmp.3, %15 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %.lr.ph.split, %._crit_edge.unr-lcssa
  %phitmp.lcssa = phi i32 [ %phitmp.lcssa.unr, %.lr.ph.split ], [ %phitmp.3.lcssa, %._crit_edge.unr-lcssa ]
  %phitmp3 = icmp eq i32 %phitmp.lcssa, 0
  br label %13

; <label>:13                                      ; preds = %0, %._crit_edge
  %sum.0.lcssa = phi i1 [ %phitmp3, %._crit_edge ], [ true, %0 ]
  %14 = zext i1 %sum.0.lcssa to i8
  ret i8 %14

; <label>:15                                      ; preds = %15, %.lr.ph.split.split
  %indvars.iv = phi i64 [ %indvars.iv.unr, %.lr.ph.split.split ], [ %indvars.iv.next.3, %15 ]
  %sum.01 = phi i32 [ %sum.01.unr, %.lr.ph.split.split ], [ %phitmp.3, %15 ]
  %16 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %header, i64 0, i32 0, i64 %indvars.iv
  %17 = load i8, i8* %16, align 1, !tbaa !9
  %18 = zext i8 %17 to i32
  %19 = add nuw nsw i32 %18, %sum.01
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %20 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %header, i64 0, i32 0, i64 %indvars.iv.next
  %21 = load i8, i8* %20, align 1, !tbaa !9
  %22 = zext i8 %21 to i32
  %23 = add nsw i32 %22, %19
  %indvars.iv.next.1 = add nsw i64 %indvars.iv, 2
  %24 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %header, i64 0, i32 0, i64 %indvars.iv.next.1
  %25 = load i8, i8* %24, align 1, !tbaa !9
  %26 = zext i8 %25 to i32
  %27 = add nsw i32 %26, %23
  %indvars.iv.next.2 = add nsw i64 %indvars.iv, 3
  %28 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %header, i64 0, i32 0, i64 %indvars.iv.next.2
  %29 = load i8, i8* %28, align 1, !tbaa !9
  %30 = zext i8 %29 to i32
  %31 = add nsw i32 %30, %27
  %indvars.iv.next.3 = add nsw i64 %indvars.iv, 4
  %phitmp.3 = and i32 %31, 255
  %32 = icmp ult i64 %indvars.iv.next.3, %4
  br i1 %32, label %15, label %._crit_edge.unr-lcssa
}

; Function Attrs: noredzone nounwind uwtable
define i8* @ACPITables_FindTable(i8* %table_name, i32 %index) #0 {
  %1 = load %struct.RSDPDescriptor20*, %struct.RSDPDescriptor20** @rsdp, align 8, !tbaa !1
  %2 = icmp eq %struct.RSDPDescriptor20* %1, null
  br i1 %2, label %.thread52, label %3

; <label>:3                                       ; preds = %0
  %4 = getelementptr inbounds %struct.RSDPDescriptor20, %struct.RSDPDescriptor20* %1, i64 0, i32 0, i32 3
  %5 = load i8, i8* %4, align 1, !tbaa !10
  %6 = icmp eq i8 %5, 0
  br i1 %6, label %._crit_edge, label %7

; <label>:7                                       ; preds = %3
  %8 = getelementptr inbounds %struct.RSDPDescriptor20, %struct.RSDPDescriptor20* %1, i64 0, i32 2
  %9 = load i64, i64* %8, align 1, !tbaa !17
  %10 = icmp eq i64 %9, 0
  br i1 %10, label %._crit_edge, label %11

; <label>:11                                      ; preds = %7
  %12 = inttoptr i64 %9 to i8*
  %13 = tail call i8* @GetVirtualAddress(i32 0, i8* %12) #3
  %14 = bitcast i8* %13 to %struct.ACPISDTHeader*
  %15 = getelementptr inbounds i8, i8* %13, i64 4
  %16 = bitcast i8* %15 to i32*
  %17 = load i32, i32* %16, align 1, !tbaa !13
  %18 = icmp eq i32 %17, 0
  br i1 %18, label %.critedge, label %.lr.ph.i

.lr.ph.i:                                         ; preds = %11
  %19 = zext i32 %17 to i64
  %20 = zext i32 %17 to i64
  %21 = add nsw i64 %20, -1
  %xtraiter111 = and i64 %20, 3
  %lcmp.mod112 = icmp eq i64 %xtraiter111, 0
  br i1 %lcmp.mod112, label %.lr.ph.i.split, label %.preheader115

.preheader115:                                    ; preds = %.lr.ph.i
  br label %22

; <label>:22                                      ; preds = %.preheader115, %22
  %indvars.iv.i.prol = phi i64 [ %indvars.iv.next.i.prol, %22 ], [ 0, %.preheader115 ]
  %sum.01.i.prol = phi i32 [ %phitmp.i.prol, %22 ], [ 0, %.preheader115 ]
  %prol.iter113 = phi i64 [ %prol.iter113.sub, %22 ], [ %xtraiter111, %.preheader115 ]
  %23 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %14, i64 0, i32 0, i64 %indvars.iv.i.prol
  %24 = load i8, i8* %23, align 1, !tbaa !9
  %25 = zext i8 %24 to i32
  %26 = add nuw nsw i32 %25, %sum.01.i.prol
  %indvars.iv.next.i.prol = add nuw nsw i64 %indvars.iv.i.prol, 1
  %phitmp.i.prol = and i32 %26, 255
  %prol.iter113.sub = add i64 %prol.iter113, -1
  %prol.iter113.cmp = icmp eq i64 %prol.iter113.sub, 0
  br i1 %prol.iter113.cmp, label %.lr.ph.i.split.loopexit, label %22, !llvm.loop !18

.lr.ph.i.split.loopexit:                          ; preds = %22
  %phitmp.i.prol.lcssa = phi i32 [ %phitmp.i.prol, %22 ]
  %indvars.iv.next.i.prol.lcssa = phi i64 [ %indvars.iv.next.i.prol, %22 ]
  br label %.lr.ph.i.split

.lr.ph.i.split:                                   ; preds = %.lr.ph.i.split.loopexit, %.lr.ph.i
  %phitmp.i.lcssa.unr = phi i32 [ undef, %.lr.ph.i ], [ %phitmp.i.prol.lcssa, %.lr.ph.i.split.loopexit ]
  %indvars.iv.i.unr = phi i64 [ 0, %.lr.ph.i ], [ %indvars.iv.next.i.prol.lcssa, %.lr.ph.i.split.loopexit ]
  %sum.01.i.unr = phi i32 [ 0, %.lr.ph.i ], [ %phitmp.i.prol.lcssa, %.lr.ph.i.split.loopexit ]
  %27 = icmp ult i64 %21, 3
  br i1 %27, label %._crit_edge.i, label %.lr.ph.i.split.split

.lr.ph.i.split.split:                             ; preds = %.lr.ph.i.split
  br label %28

._crit_edge.i.unr-lcssa:                          ; preds = %28
  %phitmp.i.3.lcssa = phi i32 [ %phitmp.i.3, %28 ]
  br label %._crit_edge.i

._crit_edge.i:                                    ; preds = %.lr.ph.i.split, %._crit_edge.i.unr-lcssa
  %phitmp.i.lcssa = phi i32 [ %phitmp.i.lcssa.unr, %.lr.ph.i.split ], [ %phitmp.i.3.lcssa, %._crit_edge.i.unr-lcssa ]
  %phitmp3.i = icmp eq i32 %phitmp.i.lcssa, 0
  br i1 %phitmp3.i, label %.critedge, label %.thread52

; <label>:28                                      ; preds = %28, %.lr.ph.i.split.split
  %indvars.iv.i = phi i64 [ %indvars.iv.i.unr, %.lr.ph.i.split.split ], [ %indvars.iv.next.i.3, %28 ]
  %sum.01.i = phi i32 [ %sum.01.i.unr, %.lr.ph.i.split.split ], [ %phitmp.i.3, %28 ]
  %29 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %14, i64 0, i32 0, i64 %indvars.iv.i
  %30 = load i8, i8* %29, align 1, !tbaa !9
  %31 = zext i8 %30 to i32
  %32 = add nuw nsw i32 %31, %sum.01.i
  %indvars.iv.next.i = add nuw nsw i64 %indvars.iv.i, 1
  %33 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %14, i64 0, i32 0, i64 %indvars.iv.next.i
  %34 = load i8, i8* %33, align 1, !tbaa !9
  %35 = zext i8 %34 to i32
  %36 = add nsw i32 %35, %32
  %indvars.iv.next.i.1 = add nsw i64 %indvars.iv.i, 2
  %37 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %14, i64 0, i32 0, i64 %indvars.iv.next.i.1
  %38 = load i8, i8* %37, align 1, !tbaa !9
  %39 = zext i8 %38 to i32
  %40 = add nsw i32 %39, %36
  %indvars.iv.next.i.2 = add nsw i64 %indvars.iv.i, 3
  %41 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %14, i64 0, i32 0, i64 %indvars.iv.next.i.2
  %42 = load i8, i8* %41, align 1, !tbaa !9
  %43 = zext i8 %42 to i32
  %44 = add nsw i32 %43, %40
  %indvars.iv.next.i.3 = add nsw i64 %indvars.iv.i, 4
  %phitmp.i.3 = and i32 %44, 255
  %exitcond91.3 = icmp eq i64 %indvars.iv.next.i.3, %19
  br i1 %exitcond91.3, label %._crit_edge.i.unr-lcssa, label %28

.critedge:                                        ; preds = %11, %._crit_edge.i
  %.pre-phi95 = phi i64 [ %19, %._crit_edge.i ], [ 0, %11 ]
  %45 = add nuw nsw i64 %.pre-phi95, 34359738332
  %46 = lshr i64 %45, 3
  %47 = trunc i64 %46 to i32
  %48 = icmp sgt i32 %47, 0
  br i1 %48, label %.lr.ph82, label %.thread52

.lr.ph82:                                         ; preds = %.critedge
  %49 = getelementptr inbounds i8, i8* %13, i64 36
  %50 = bitcast i8* %49 to [1 x i64]*
  %sext = shl i64 %46, 32
  %51 = ashr exact i64 %sext, 32
  br label %52

; <label>:52                                      ; preds = %.lr.ph82, %.thread
  %indvars.iv89 = phi i64 [ 0, %.lr.ph82 ], [ %indvars.iv.next90, %.thread ]
  %cur_index.080 = phi i32 [ 0, %.lr.ph82 ], [ %cur_index.3, %.thread ]
  %53 = getelementptr inbounds [1 x i64], [1 x i64]* %50, i64 0, i64 %indvars.iv89
  %54 = load i64, i64* %53, align 1, !tbaa !19
  %55 = icmp eq i64 %54, 0
  br i1 %55, label %.thread, label %56

; <label>:56                                      ; preds = %52
  %57 = inttoptr i64 %54 to i8*
  %58 = tail call i8* @GetVirtualAddress(i32 0, i8* %57) #3
  %59 = tail call i32 @strncmp(i8* %58, i8* %table_name, i64 4) #3
  %60 = icmp eq i32 %59, 0
  br i1 %60, label %61, label %.thread

; <label>:61                                      ; preds = %56
  %62 = bitcast i8* %58 to %struct.ACPISDTHeader*
  %63 = getelementptr inbounds i8, i8* %58, i64 4
  %64 = bitcast i8* %63 to i32*
  %65 = load i32, i32* %64, align 1, !tbaa !13
  %66 = icmp eq i32 %65, 0
  br i1 %66, label %.critedge70, label %.lr.ph.i.41

.lr.ph.i.41:                                      ; preds = %61
  %67 = zext i32 %65 to i64
  %68 = zext i32 %65 to i64
  %69 = add nsw i64 %68, -1
  %xtraiter107 = and i64 %68, 3
  %lcmp.mod108 = icmp eq i64 %xtraiter107, 0
  br i1 %lcmp.mod108, label %.lr.ph.i.41.split, label %.preheader110

.preheader110:                                    ; preds = %.lr.ph.i.41
  br label %70

; <label>:70                                      ; preds = %70, %.preheader110
  %indvars.iv.i.45.prol = phi i64 [ %indvars.iv.next.i.47.prol, %70 ], [ 0, %.preheader110 ]
  %sum.01.i.46.prol = phi i32 [ %phitmp.i.48.prol, %70 ], [ 0, %.preheader110 ]
  %prol.iter109 = phi i64 [ %prol.iter109.sub, %70 ], [ %xtraiter107, %.preheader110 ]
  %71 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %62, i64 0, i32 0, i64 %indvars.iv.i.45.prol
  %72 = load i8, i8* %71, align 1, !tbaa !9
  %73 = zext i8 %72 to i32
  %74 = add nuw nsw i32 %73, %sum.01.i.46.prol
  %indvars.iv.next.i.47.prol = add nuw nsw i64 %indvars.iv.i.45.prol, 1
  %phitmp.i.48.prol = and i32 %74, 255
  %prol.iter109.sub = add i64 %prol.iter109, -1
  %prol.iter109.cmp = icmp eq i64 %prol.iter109.sub, 0
  br i1 %prol.iter109.cmp, label %.lr.ph.i.41.split.loopexit, label %70, !llvm.loop !20

.lr.ph.i.41.split.loopexit:                       ; preds = %70
  %phitmp.i.48.prol.lcssa = phi i32 [ %phitmp.i.48.prol, %70 ]
  %indvars.iv.next.i.47.prol.lcssa = phi i64 [ %indvars.iv.next.i.47.prol, %70 ]
  br label %.lr.ph.i.41.split

.lr.ph.i.41.split:                                ; preds = %.lr.ph.i.41, %.lr.ph.i.41.split.loopexit
  %phitmp.i.48.lcssa.unr = phi i32 [ undef, %.lr.ph.i.41 ], [ %phitmp.i.48.prol.lcssa, %.lr.ph.i.41.split.loopexit ]
  %indvars.iv.i.45.unr = phi i64 [ 0, %.lr.ph.i.41 ], [ %indvars.iv.next.i.47.prol.lcssa, %.lr.ph.i.41.split.loopexit ]
  %sum.01.i.46.unr = phi i32 [ 0, %.lr.ph.i.41 ], [ %phitmp.i.48.prol.lcssa, %.lr.ph.i.41.split.loopexit ]
  %75 = icmp ult i64 %69, 3
  br i1 %75, label %._crit_edge.i.43, label %.lr.ph.i.41.split.split

.lr.ph.i.41.split.split:                          ; preds = %.lr.ph.i.41.split
  br label %76

._crit_edge.i.43.unr-lcssa:                       ; preds = %76
  %phitmp.i.48.3.lcssa = phi i32 [ %phitmp.i.48.3, %76 ]
  br label %._crit_edge.i.43

._crit_edge.i.43:                                 ; preds = %.lr.ph.i.41.split, %._crit_edge.i.43.unr-lcssa
  %phitmp.i.48.lcssa = phi i32 [ %phitmp.i.48.lcssa.unr, %.lr.ph.i.41.split ], [ %phitmp.i.48.3.lcssa, %._crit_edge.i.43.unr-lcssa ]
  %phitmp3.i.42 = icmp eq i32 %phitmp.i.48.lcssa, 0
  br i1 %phitmp3.i.42, label %.critedge70, label %.thread

; <label>:76                                      ; preds = %76, %.lr.ph.i.41.split.split
  %indvars.iv.i.45 = phi i64 [ %indvars.iv.i.45.unr, %.lr.ph.i.41.split.split ], [ %indvars.iv.next.i.47.3, %76 ]
  %sum.01.i.46 = phi i32 [ %sum.01.i.46.unr, %.lr.ph.i.41.split.split ], [ %phitmp.i.48.3, %76 ]
  %77 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %62, i64 0, i32 0, i64 %indvars.iv.i.45
  %78 = load i8, i8* %77, align 1, !tbaa !9
  %79 = zext i8 %78 to i32
  %80 = add nuw nsw i32 %79, %sum.01.i.46
  %indvars.iv.next.i.47 = add nuw nsw i64 %indvars.iv.i.45, 1
  %81 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %62, i64 0, i32 0, i64 %indvars.iv.next.i.47
  %82 = load i8, i8* %81, align 1, !tbaa !9
  %83 = zext i8 %82 to i32
  %84 = add nsw i32 %83, %80
  %indvars.iv.next.i.47.1 = add nsw i64 %indvars.iv.i.45, 2
  %85 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %62, i64 0, i32 0, i64 %indvars.iv.next.i.47.1
  %86 = load i8, i8* %85, align 1, !tbaa !9
  %87 = zext i8 %86 to i32
  %88 = add nsw i32 %87, %84
  %indvars.iv.next.i.47.2 = add nsw i64 %indvars.iv.i.45, 3
  %89 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %62, i64 0, i32 0, i64 %indvars.iv.next.i.47.2
  %90 = load i8, i8* %89, align 1, !tbaa !9
  %91 = zext i8 %90 to i32
  %92 = add nsw i32 %91, %88
  %indvars.iv.next.i.47.3 = add nsw i64 %indvars.iv.i.45, 4
  %phitmp.i.48.3 = and i32 %92, 255
  %exitcond88.3 = icmp eq i64 %indvars.iv.next.i.47.3, %67
  br i1 %exitcond88.3, label %._crit_edge.i.43.unr-lcssa, label %76

.critedge70:                                      ; preds = %61, %._crit_edge.i.43
  %93 = icmp eq i32 %cur_index.080, %index
  %94 = add nsw i32 %cur_index.080, 1
  br i1 %93, label %.thread52.loopexit102, label %.thread

.thread:                                          ; preds = %._crit_edge.i.43, %.critedge70, %56, %52
  %cur_index.3 = phi i32 [ %cur_index.080, %52 ], [ %94, %.critedge70 ], [ %cur_index.080, %._crit_edge.i.43 ], [ %cur_index.080, %56 ]
  %indvars.iv.next90 = add nuw nsw i64 %indvars.iv89, 1
  %95 = icmp slt i64 %indvars.iv.next90, %51
  br i1 %95, label %52, label %.thread52.loopexit102

._crit_edge:                                      ; preds = %3, %7
  %96 = getelementptr inbounds %struct.RSDPDescriptor20, %struct.RSDPDescriptor20* %1, i64 0, i32 0, i32 4
  %97 = load i32, i32* %96, align 1, !tbaa !21
  %98 = zext i32 %97 to i64
  %99 = inttoptr i64 %98 to i8*
  %100 = tail call i8* @GetVirtualAddress(i32 0, i8* %99) #3
  %101 = bitcast i8* %100 to %struct.ACPISDTHeader*
  %102 = getelementptr inbounds i8, i8* %100, i64 4
  %103 = bitcast i8* %102 to i32*
  %104 = load i32, i32* %103, align 1, !tbaa !13
  %105 = icmp eq i32 %104, 0
  br i1 %105, label %.critedge71, label %.lr.ph.i.32

.lr.ph.i.32:                                      ; preds = %._crit_edge
  %106 = zext i32 %104 to i64
  %107 = zext i32 %104 to i64
  %108 = add nsw i64 %107, -1
  %xtraiter104 = and i64 %107, 3
  %lcmp.mod105 = icmp eq i64 %xtraiter104, 0
  br i1 %lcmp.mod105, label %.lr.ph.i.32.split, label %.preheader114

.preheader114:                                    ; preds = %.lr.ph.i.32
  br label %109

; <label>:109                                     ; preds = %.preheader114, %109
  %indvars.iv.i.36.prol = phi i64 [ %indvars.iv.next.i.38.prol, %109 ], [ 0, %.preheader114 ]
  %sum.01.i.37.prol = phi i32 [ %phitmp.i.39.prol, %109 ], [ 0, %.preheader114 ]
  %prol.iter106 = phi i64 [ %prol.iter106.sub, %109 ], [ %xtraiter104, %.preheader114 ]
  %110 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %101, i64 0, i32 0, i64 %indvars.iv.i.36.prol
  %111 = load i8, i8* %110, align 1, !tbaa !9
  %112 = zext i8 %111 to i32
  %113 = add nuw nsw i32 %112, %sum.01.i.37.prol
  %indvars.iv.next.i.38.prol = add nuw nsw i64 %indvars.iv.i.36.prol, 1
  %phitmp.i.39.prol = and i32 %113, 255
  %prol.iter106.sub = add i64 %prol.iter106, -1
  %prol.iter106.cmp = icmp eq i64 %prol.iter106.sub, 0
  br i1 %prol.iter106.cmp, label %.lr.ph.i.32.split.loopexit, label %109, !llvm.loop !22

.lr.ph.i.32.split.loopexit:                       ; preds = %109
  %phitmp.i.39.prol.lcssa = phi i32 [ %phitmp.i.39.prol, %109 ]
  %indvars.iv.next.i.38.prol.lcssa = phi i64 [ %indvars.iv.next.i.38.prol, %109 ]
  br label %.lr.ph.i.32.split

.lr.ph.i.32.split:                                ; preds = %.lr.ph.i.32.split.loopexit, %.lr.ph.i.32
  %phitmp.i.39.lcssa.unr = phi i32 [ undef, %.lr.ph.i.32 ], [ %phitmp.i.39.prol.lcssa, %.lr.ph.i.32.split.loopexit ]
  %indvars.iv.i.36.unr = phi i64 [ 0, %.lr.ph.i.32 ], [ %indvars.iv.next.i.38.prol.lcssa, %.lr.ph.i.32.split.loopexit ]
  %sum.01.i.37.unr = phi i32 [ 0, %.lr.ph.i.32 ], [ %phitmp.i.39.prol.lcssa, %.lr.ph.i.32.split.loopexit ]
  %114 = icmp ult i64 %108, 3
  br i1 %114, label %._crit_edge.i.34, label %.lr.ph.i.32.split.split

.lr.ph.i.32.split.split:                          ; preds = %.lr.ph.i.32.split
  br label %115

._crit_edge.i.34.unr-lcssa:                       ; preds = %115
  %phitmp.i.39.3.lcssa = phi i32 [ %phitmp.i.39.3, %115 ]
  br label %._crit_edge.i.34

._crit_edge.i.34:                                 ; preds = %.lr.ph.i.32.split, %._crit_edge.i.34.unr-lcssa
  %phitmp.i.39.lcssa = phi i32 [ %phitmp.i.39.lcssa.unr, %.lr.ph.i.32.split ], [ %phitmp.i.39.3.lcssa, %._crit_edge.i.34.unr-lcssa ]
  %phitmp3.i.33 = icmp eq i32 %phitmp.i.39.lcssa, 0
  br i1 %phitmp3.i.33, label %.critedge71, label %.thread52

; <label>:115                                     ; preds = %115, %.lr.ph.i.32.split.split
  %indvars.iv.i.36 = phi i64 [ %indvars.iv.i.36.unr, %.lr.ph.i.32.split.split ], [ %indvars.iv.next.i.38.3, %115 ]
  %sum.01.i.37 = phi i32 [ %sum.01.i.37.unr, %.lr.ph.i.32.split.split ], [ %phitmp.i.39.3, %115 ]
  %116 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %101, i64 0, i32 0, i64 %indvars.iv.i.36
  %117 = load i8, i8* %116, align 1, !tbaa !9
  %118 = zext i8 %117 to i32
  %119 = add nuw nsw i32 %118, %sum.01.i.37
  %indvars.iv.next.i.38 = add nuw nsw i64 %indvars.iv.i.36, 1
  %120 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %101, i64 0, i32 0, i64 %indvars.iv.next.i.38
  %121 = load i8, i8* %120, align 1, !tbaa !9
  %122 = zext i8 %121 to i32
  %123 = add nsw i32 %122, %119
  %indvars.iv.next.i.38.1 = add nsw i64 %indvars.iv.i.36, 2
  %124 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %101, i64 0, i32 0, i64 %indvars.iv.next.i.38.1
  %125 = load i8, i8* %124, align 1, !tbaa !9
  %126 = zext i8 %125 to i32
  %127 = add nsw i32 %126, %123
  %indvars.iv.next.i.38.2 = add nsw i64 %indvars.iv.i.36, 3
  %128 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %101, i64 0, i32 0, i64 %indvars.iv.next.i.38.2
  %129 = load i8, i8* %128, align 1, !tbaa !9
  %130 = zext i8 %129 to i32
  %131 = add nsw i32 %130, %127
  %indvars.iv.next.i.38.3 = add nsw i64 %indvars.iv.i.36, 4
  %phitmp.i.39.3 = and i32 %131, 255
  %exitcond87.3 = icmp eq i64 %indvars.iv.next.i.38.3, %106
  br i1 %exitcond87.3, label %._crit_edge.i.34.unr-lcssa, label %115

.critedge71:                                      ; preds = %._crit_edge, %._crit_edge.i.34
  %.pre-phi93 = phi i64 [ %106, %._crit_edge.i.34 ], [ 0, %._crit_edge ]
  %132 = add nuw nsw i64 %.pre-phi93, 17179869148
  %133 = lshr i64 %132, 2
  %134 = trunc i64 %133 to i32
  %135 = icmp sgt i32 %134, 0
  br i1 %135, label %.lr.ph, label %.thread52

.lr.ph:                                           ; preds = %.critedge71
  %136 = getelementptr inbounds i8, i8* %100, i64 36
  %137 = bitcast i8* %136 to [1 x i32]*
  %sext96 = shl i64 %133, 32
  %138 = ashr exact i64 %sext96, 32
  br label %139

; <label>:139                                     ; preds = %.lr.ph, %181
  %indvars.iv = phi i64 [ 0, %.lr.ph ], [ %indvars.iv.next, %181 ]
  %cur_index4.075 = phi i32 [ 0, %.lr.ph ], [ %cur_index4.2.ph, %181 ]
  %140 = getelementptr inbounds [1 x i32], [1 x i32]* %137, i64 0, i64 %indvars.iv
  %141 = load i32, i32* %140, align 1, !tbaa !23
  %142 = zext i32 %141 to i64
  %143 = inttoptr i64 %142 to i8*
  %144 = tail call i8* @GetVirtualAddress(i32 0, i8* %143) #3
  %145 = tail call i32 @strncmp(i8* %144, i8* %table_name, i64 4) #3
  %146 = icmp eq i32 %145, 0
  br i1 %146, label %147, label %181

; <label>:147                                     ; preds = %139
  %148 = bitcast i8* %144 to %struct.ACPISDTHeader*
  %149 = getelementptr inbounds i8, i8* %144, i64 4
  %150 = bitcast i8* %149 to i32*
  %151 = load i32, i32* %150, align 1, !tbaa !13
  %152 = icmp eq i32 %151, 0
  br i1 %152, label %.critedge72, label %.lr.ph.i.23

.lr.ph.i.23:                                      ; preds = %147
  %153 = zext i32 %151 to i64
  %154 = zext i32 %151 to i64
  %155 = add nsw i64 %154, -1
  %xtraiter = and i64 %154, 3
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.i.23.split, label %.preheader

.preheader:                                       ; preds = %.lr.ph.i.23
  br label %156

; <label>:156                                     ; preds = %156, %.preheader
  %indvars.iv.i.27.prol = phi i64 [ %indvars.iv.next.i.29.prol, %156 ], [ 0, %.preheader ]
  %sum.01.i.28.prol = phi i32 [ %phitmp.i.30.prol, %156 ], [ 0, %.preheader ]
  %prol.iter = phi i64 [ %prol.iter.sub, %156 ], [ %xtraiter, %.preheader ]
  %157 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %148, i64 0, i32 0, i64 %indvars.iv.i.27.prol
  %158 = load i8, i8* %157, align 1, !tbaa !9
  %159 = zext i8 %158 to i32
  %160 = add nuw nsw i32 %159, %sum.01.i.28.prol
  %indvars.iv.next.i.29.prol = add nuw nsw i64 %indvars.iv.i.27.prol, 1
  %phitmp.i.30.prol = and i32 %160, 255
  %prol.iter.sub = add i64 %prol.iter, -1
  %prol.iter.cmp = icmp eq i64 %prol.iter.sub, 0
  br i1 %prol.iter.cmp, label %.lr.ph.i.23.split.loopexit, label %156, !llvm.loop !24

.lr.ph.i.23.split.loopexit:                       ; preds = %156
  %phitmp.i.30.prol.lcssa = phi i32 [ %phitmp.i.30.prol, %156 ]
  %indvars.iv.next.i.29.prol.lcssa = phi i64 [ %indvars.iv.next.i.29.prol, %156 ]
  br label %.lr.ph.i.23.split

.lr.ph.i.23.split:                                ; preds = %.lr.ph.i.23, %.lr.ph.i.23.split.loopexit
  %phitmp.i.30.lcssa.unr = phi i32 [ undef, %.lr.ph.i.23 ], [ %phitmp.i.30.prol.lcssa, %.lr.ph.i.23.split.loopexit ]
  %indvars.iv.i.27.unr = phi i64 [ 0, %.lr.ph.i.23 ], [ %indvars.iv.next.i.29.prol.lcssa, %.lr.ph.i.23.split.loopexit ]
  %sum.01.i.28.unr = phi i32 [ 0, %.lr.ph.i.23 ], [ %phitmp.i.30.prol.lcssa, %.lr.ph.i.23.split.loopexit ]
  %161 = icmp ult i64 %155, 3
  br i1 %161, label %._crit_edge.i.25, label %.lr.ph.i.23.split.split

.lr.ph.i.23.split.split:                          ; preds = %.lr.ph.i.23.split
  br label %162

._crit_edge.i.25.unr-lcssa:                       ; preds = %162
  %phitmp.i.30.3.lcssa = phi i32 [ %phitmp.i.30.3, %162 ]
  br label %._crit_edge.i.25

._crit_edge.i.25:                                 ; preds = %.lr.ph.i.23.split, %._crit_edge.i.25.unr-lcssa
  %phitmp.i.30.lcssa = phi i32 [ %phitmp.i.30.lcssa.unr, %.lr.ph.i.23.split ], [ %phitmp.i.30.3.lcssa, %._crit_edge.i.25.unr-lcssa ]
  %phitmp3.i.24 = icmp eq i32 %phitmp.i.30.lcssa, 0
  br i1 %phitmp3.i.24, label %.critedge72, label %181

; <label>:162                                     ; preds = %162, %.lr.ph.i.23.split.split
  %indvars.iv.i.27 = phi i64 [ %indvars.iv.i.27.unr, %.lr.ph.i.23.split.split ], [ %indvars.iv.next.i.29.3, %162 ]
  %sum.01.i.28 = phi i32 [ %sum.01.i.28.unr, %.lr.ph.i.23.split.split ], [ %phitmp.i.30.3, %162 ]
  %163 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %148, i64 0, i32 0, i64 %indvars.iv.i.27
  %164 = load i8, i8* %163, align 1, !tbaa !9
  %165 = zext i8 %164 to i32
  %166 = add nuw nsw i32 %165, %sum.01.i.28
  %indvars.iv.next.i.29 = add nuw nsw i64 %indvars.iv.i.27, 1
  %167 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %148, i64 0, i32 0, i64 %indvars.iv.next.i.29
  %168 = load i8, i8* %167, align 1, !tbaa !9
  %169 = zext i8 %168 to i32
  %170 = add nsw i32 %169, %166
  %indvars.iv.next.i.29.1 = add nsw i64 %indvars.iv.i.27, 2
  %171 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %148, i64 0, i32 0, i64 %indvars.iv.next.i.29.1
  %172 = load i8, i8* %171, align 1, !tbaa !9
  %173 = zext i8 %172 to i32
  %174 = add nsw i32 %173, %170
  %indvars.iv.next.i.29.2 = add nsw i64 %indvars.iv.i.27, 3
  %175 = getelementptr inbounds %struct.ACPISDTHeader, %struct.ACPISDTHeader* %148, i64 0, i32 0, i64 %indvars.iv.next.i.29.2
  %176 = load i8, i8* %175, align 1, !tbaa !9
  %177 = zext i8 %176 to i32
  %178 = add nsw i32 %177, %174
  %indvars.iv.next.i.29.3 = add nsw i64 %indvars.iv.i.27, 4
  %phitmp.i.30.3 = and i32 %178, 255
  %exitcond.3 = icmp eq i64 %indvars.iv.next.i.29.3, %153
  br i1 %exitcond.3, label %._crit_edge.i.25.unr-lcssa, label %162

.critedge72:                                      ; preds = %147, %._crit_edge.i.25
  %179 = icmp eq i32 %cur_index4.075, %index
  %180 = add nsw i32 %cur_index4.075, 1
  br i1 %179, label %.thread52.loopexit, label %181

; <label>:181                                     ; preds = %._crit_edge.i.25, %139, %.critedge72
  %cur_index4.2.ph = phi i32 [ %180, %.critedge72 ], [ %cur_index4.075, %._crit_edge.i.25 ], [ %cur_index4.075, %139 ]
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %182 = icmp slt i64 %indvars.iv.next, %138
  br i1 %182, label %139, label %.thread52.loopexit

.thread52.loopexit:                               ; preds = %.critedge72, %181
  %.9.ph = phi i8* [ %144, %.critedge72 ], [ null, %181 ]
  br label %.thread52

.thread52.loopexit102:                            ; preds = %.critedge70, %.thread
  %.9.ph103 = phi i8* [ %58, %.critedge70 ], [ null, %.thread ]
  br label %.thread52

.thread52:                                        ; preds = %.thread52.loopexit102, %.thread52.loopexit, %.critedge, %.critedge71, %._crit_edge.i.34, %._crit_edge.i, %0
  %.9 = phi i8* [ null, %0 ], [ inttoptr (i64 -1 to i8*), %._crit_edge.i ], [ null, %._crit_edge.i.34 ], [ null, %.critedge71 ], [ null, %.critedge ], [ %.9.ph, %.thread52.loopexit ], [ %.9.ph103, %.thread52.loopexit102 ]
  ret i8* %.9
}

; Function Attrs: noredzone
declare i8* @GetVirtualAddress(i32, i8*) #1

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { noredzone nounwind readonly uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { nobuiltin noredzone nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"any pointer", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!6, !7, i64 40}
!6 = !{!"", !7, i64 0, !8, i64 8, !8, i64 12, !8, i64 16, !8, i64 20, !8, i64 24, !8, i64 28, !7, i64 32, !7, i64 40, !7, i64 48, !7, i64 56, !2, i64 64, !7, i64 72, !8, i64 80, !8, i64 84, !8, i64 88, !3, i64 92}
!7 = !{!"long", !3, i64 0}
!8 = !{!"int", !3, i64 0}
!9 = !{!3, !3, i64 0}
!10 = !{!11, !3, i64 15}
!11 = !{!"", !12, i64 0, !8, i64 20, !7, i64 24, !3, i64 32, !3, i64 33}
!12 = !{!"", !3, i64 0, !3, i64 8, !3, i64 9, !3, i64 15, !8, i64 16}
!13 = !{!14, !8, i64 4}
!14 = !{!"", !3, i64 0, !8, i64 4, !3, i64 8, !3, i64 9, !3, i64 10, !3, i64 16, !8, i64 24, !8, i64 28, !8, i64 32}
!15 = distinct !{!15, !16}
!16 = !{!"llvm.loop.unroll.disable"}
!17 = !{!11, !7, i64 24}
!18 = distinct !{!18, !16}
!19 = !{!7, !7, i64 0}
!20 = distinct !{!20, !16}
!21 = !{!11, !8, i64 16}
!22 = distinct !{!22, !16}
!23 = !{!8, !8, i64 0}
!24 = distinct !{!24, !16}
