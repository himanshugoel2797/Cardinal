; ModuleID = 'managers/syscall_manager/syscall.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.SyscallData = type { i64, i64*, i64 }

@syscall_lock = internal unnamed_addr global i64* null, align 8
@Syscalls = common global [256 x i64 (i64, i64, i64*)*] zeroinitializer, align 16
@free_syscall_index = internal unnamed_addr global i64 0, align 8

; Function Attrs: noredzone nounwind uwtable
define void @SyscallMan_Initialize() #0 {
  %1 = tail call i64* @CreateSpinlock() #3
  store i64* %1, i64** @syscall_lock, align 8, !tbaa !1
  tail call void @RegisterAllSyscalls() #3
  ret void
}

; Function Attrs: noredzone
declare i64* @CreateSpinlock() #1

; Function Attrs: noredzone
declare void @RegisterAllSyscalls() #1

; Function Attrs: noredzone nounwind uwtable
define i64 @SyscallReceived(i64 %instruction_pointer, i64 %syscall_num, i64* %syscall_params, i64 %syscall_param_cnt) #0 {
  %flags = alloca i32, align 4
  %k_data = alloca %struct.SyscallData, align 8
  %k_data_param = alloca [6 x i64], align 16
  %1 = bitcast i32* %flags to i8*
  call void @llvm.lifetime.start(i64 4, i8* %1) #2
  store i32 0, i32* %flags, align 4, !tbaa !5
  %2 = tail call i64 @GetActiveVirtualMemoryInstance() #3
  %3 = ptrtoint i64* %syscall_params to i64
  call void @CheckAddressPermissions(i64 %2, i64 %3, i32* null, i32* nonnull %flags) #3
  %4 = load i32, i32* %flags, align 4, !tbaa !5
  %5 = icmp eq i32 %4, 13
  br i1 %5, label %6, label %52

; <label>:6                                       ; preds = %0
  %7 = bitcast %struct.SyscallData* %k_data to i8*
  call void @llvm.lifetime.start(i64 24, i8* %7) #2
  %8 = getelementptr inbounds %struct.SyscallData, %struct.SyscallData* %k_data, i64 0, i32 1
  store i64* %syscall_params, i64** %8, align 8, !tbaa !6
  %9 = getelementptr inbounds %struct.SyscallData, %struct.SyscallData* %k_data, i64 0, i32 2
  store i64 %syscall_param_cnt, i64* %9, align 8, !tbaa !9
  %10 = icmp ugt i64 %syscall_param_cnt, 6
  br i1 %10, label %51, label %11

; <label>:11                                      ; preds = %6
  %12 = bitcast [6 x i64]* %k_data_param to i8*
  call void @llvm.lifetime.start(i64 48, i8* %12) #2
  %13 = icmp eq i64 %syscall_param_cnt, 0
  br i1 %13, label %._crit_edge, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %11
  %14 = add i64 %syscall_param_cnt, -1
  %xtraiter = and i64 %syscall_param_cnt, 3
  %lcmp.mod = icmp eq i64 %xtraiter, 0
  br i1 %lcmp.mod, label %.lr.ph.preheader.split, label %.lr.ph.prol.preheader

.lr.ph.prol.preheader:                            ; preds = %.lr.ph.preheader
  br label %.lr.ph.prol

.lr.ph.prol:                                      ; preds = %.lr.ph.prol.preheader, %.lr.ph.prol
  %i.01.prol = phi i64 [ %18, %.lr.ph.prol ], [ 0, %.lr.ph.prol.preheader ]
  %prol.iter = phi i64 [ %prol.iter.sub, %.lr.ph.prol ], [ %xtraiter, %.lr.ph.prol.preheader ]
  %15 = getelementptr inbounds i64, i64* %syscall_params, i64 %i.01.prol
  %16 = load i64, i64* %15, align 8, !tbaa !10
  %17 = getelementptr inbounds [6 x i64], [6 x i64]* %k_data_param, i64 0, i64 %i.01.prol
  store i64 %16, i64* %17, align 8, !tbaa !10
  %18 = add i64 %i.01.prol, 1
  %prol.iter.sub = add i64 %prol.iter, -1
  %prol.iter.cmp = icmp eq i64 %prol.iter.sub, 0
  br i1 %prol.iter.cmp, label %.lr.ph.preheader.split.loopexit, label %.lr.ph.prol, !llvm.loop !11

.lr.ph.preheader.split.loopexit:                  ; preds = %.lr.ph.prol
  %.lcssa = phi i64 [ %18, %.lr.ph.prol ]
  br label %.lr.ph.preheader.split

.lr.ph.preheader.split:                           ; preds = %.lr.ph.preheader.split.loopexit, %.lr.ph.preheader
  %i.01.unr = phi i64 [ 0, %.lr.ph.preheader ], [ %.lcssa, %.lr.ph.preheader.split.loopexit ]
  %19 = icmp ult i64 %14, 3
  br i1 %19, label %._crit_edge.loopexit, label %.lr.ph.preheader.split.split

.lr.ph.preheader.split.split:                     ; preds = %.lr.ph.preheader.split
  br label %.lr.ph

._crit_edge.loopexit.unr-lcssa:                   ; preds = %.lr.ph
  br label %._crit_edge.loopexit

._crit_edge.loopexit:                             ; preds = %.lr.ph.preheader.split, %._crit_edge.loopexit.unr-lcssa
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %11
  %20 = getelementptr inbounds [6 x i64], [6 x i64]* %k_data_param, i64 0, i64 0
  store i64* %20, i64** %8, align 8, !tbaa !6
  %21 = trunc i64 %syscall_num to i32
  %22 = add i32 %21, -1
  %23 = icmp ugt i32 %22, 218
  br i1 %23, label %50, label %41

.lr.ph:                                           ; preds = %.lr.ph, %.lr.ph.preheader.split.split
  %i.01 = phi i64 [ %i.01.unr, %.lr.ph.preheader.split.split ], [ %39, %.lr.ph ]
  %24 = getelementptr inbounds i64, i64* %syscall_params, i64 %i.01
  %25 = load i64, i64* %24, align 8, !tbaa !10
  %26 = getelementptr inbounds [6 x i64], [6 x i64]* %k_data_param, i64 0, i64 %i.01
  store i64 %25, i64* %26, align 8, !tbaa !10
  %27 = add i64 %i.01, 1
  %28 = getelementptr inbounds i64, i64* %syscall_params, i64 %27
  %29 = load i64, i64* %28, align 8, !tbaa !10
  %30 = getelementptr inbounds [6 x i64], [6 x i64]* %k_data_param, i64 0, i64 %27
  store i64 %29, i64* %30, align 8, !tbaa !10
  %31 = add i64 %i.01, 2
  %32 = getelementptr inbounds i64, i64* %syscall_params, i64 %31
  %33 = load i64, i64* %32, align 8, !tbaa !10
  %34 = getelementptr inbounds [6 x i64], [6 x i64]* %k_data_param, i64 0, i64 %31
  store i64 %33, i64* %34, align 8, !tbaa !10
  %35 = add i64 %i.01, 3
  %36 = getelementptr inbounds i64, i64* %syscall_params, i64 %35
  %37 = load i64, i64* %36, align 8, !tbaa !10
  %38 = getelementptr inbounds [6 x i64], [6 x i64]* %k_data_param, i64 0, i64 %35
  store i64 %37, i64* %38, align 8, !tbaa !10
  %39 = add i64 %i.01, 4
  %40 = icmp ult i64 %39, %syscall_param_cnt
  br i1 %40, label %.lr.ph, label %._crit_edge.loopexit.unr-lcssa

; <label>:41                                      ; preds = %._crit_edge
  %42 = and i64 %syscall_num, 4294967295
  %43 = getelementptr inbounds [256 x i64 (i64, i64, i64*)*], [256 x i64 (i64, i64, i64*)*]* @Syscalls, i64 0, i64 %42
  %44 = load i64 (i64, i64, i64*)*, i64 (i64, i64, i64*)** %43, align 8, !tbaa !1
  %45 = icmp eq i64 (i64, i64, i64*)* %44, null
  br i1 %45, label %49, label %46

; <label>:46                                      ; preds = %41
  %47 = getelementptr inbounds %struct.SyscallData, %struct.SyscallData* %k_data, i64 0, i32 0
  %48 = call i64 %44(i64 %instruction_pointer, i64 %syscall_num, i64* %47) #3
  br label %50

; <label>:49                                      ; preds = %41
  call void asm sideeffect "cli\0A\09hlt", "{ax},{bx},~{dirflag},~{fpsr},~{flags}"(i64 %syscall_num, i64 %instruction_pointer) #2, !srcloc !13
  br label %50

; <label>:50                                      ; preds = %._crit_edge, %49, %46
  %.0 = phi i64 [ %48, %46 ], [ 38, %49 ], [ 38, %._crit_edge ]
  call void @llvm.lifetime.end(i64 48, i8* %12) #2
  br label %51

; <label>:51                                      ; preds = %6, %50
  %.1 = phi i64 [ %.0, %50 ], [ 22, %6 ]
  call void @llvm.lifetime.end(i64 24, i8* %7) #2
  br label %52

; <label>:52                                      ; preds = %0, %51
  %.2 = phi i64 [ %.1, %51 ], [ 22, %0 ]
  call void @llvm.lifetime.end(i64 4, i8* %1) #2
  ret i64 %.2
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #2

; Function Attrs: noredzone
declare void @CheckAddressPermissions(i64, i64, i32*, i32*) #1

; Function Attrs: noredzone
declare i64 @GetActiveVirtualMemoryInstance() #1

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #2

; Function Attrs: noredzone nounwind uwtable
define i64 @AllocateSyscall() #0 {
  %1 = load i64*, i64** @syscall_lock, align 8, !tbaa !1
  %2 = tail call zeroext i8 @LockSpinlock(i64* %1) #3
  %3 = load i64, i64* @free_syscall_index, align 8, !tbaa !10
  %4 = add i64 %3, 1
  store i64 %4, i64* @free_syscall_index, align 8, !tbaa !10
  %5 = load i64*, i64** @syscall_lock, align 8, !tbaa !1
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #3
  ret i64 %3
}

; Function Attrs: noredzone
declare zeroext i8 @LockSpinlock(i64*) #1

; Function Attrs: noredzone
declare zeroext i8 @UnlockSpinlock(i64*) #1

; Function Attrs: noredzone nounwind uwtable
define void @RegisterSyscall(i64 %syscall_num, i64 (i64, i64, i64*)* %handler) #0 {
  %1 = icmp ult i64 %syscall_num, 256
  br i1 %1, label %2, label %8

; <label>:2                                       ; preds = %0
  %3 = load i64*, i64** @syscall_lock, align 8, !tbaa !1
  %4 = tail call zeroext i8 @LockSpinlock(i64* %3) #3
  %5 = getelementptr inbounds [256 x i64 (i64, i64, i64*)*], [256 x i64 (i64, i64, i64*)*]* @Syscalls, i64 0, i64 %syscall_num
  store i64 (i64, i64, i64*)* %handler, i64 (i64, i64, i64*)** %5, align 8, !tbaa !1
  %6 = load i64*, i64** @syscall_lock, align 8, !tbaa !1
  %7 = tail call zeroext i8 @UnlockSpinlock(i64* %6) #3
  br label %8

; <label>:8                                       ; preds = %2, %0
  ret void
}

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { nobuiltin noredzone nounwind }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{!2, !2, i64 0}
!2 = !{!"any pointer", !3, i64 0}
!3 = !{!"omnipotent char", !4, i64 0}
!4 = !{!"Simple C/C++ TBAA"}
!5 = !{!3, !3, i64 0}
!6 = !{!7, !2, i64 8}
!7 = !{!"", !8, i64 0, !2, i64 8, !8, i64 16}
!8 = !{!"long", !3, i64 0}
!9 = !{!7, !8, i64 16}
!10 = !{!8, !8, i64 0}
!11 = distinct !{!11, !12}
!12 = !{!"llvm.loop.unroll.disable"}
!13 = !{i32 1814, i32 1820}
