; ModuleID = 'managers/thread_manager/thread.c'
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-none--elf"

%struct.CoreThreadState = type { %struct.ThreadInfo*, i32 }
%struct.ThreadInfo = type { i64, i64, %struct.ProcessInformation*, void ()*, i32, i32, i32, i64, i64, i64, i64, i64, i64, i64, i64, i32, i64, i64, i8*, i8*, i8*, i8*, i64* }
%struct.ProcessInformation = type { i64, [256 x i8], i32, i32, i32, [22 x void (i32)*], i64, %struct.MemoryAllocationsMap*, %struct.List*, i32, i64* }
%struct.MemoryAllocationsMap = type { i32, i64, i64, i64, i32, i32, i64, i64, %struct.MemoryAllocationsMap* }
%struct.List = type opaque

@coreState = internal unnamed_addr global %struct.CoreThreadState* null, align 8
@vLow = internal unnamed_addr global %struct.List* null, align 8
@low = internal unnamed_addr global %struct.List* null, align 8
@medium = internal unnamed_addr global %struct.List* null, align 8
@neutral = internal unnamed_addr global %struct.List* null, align 8
@high = internal unnamed_addr global %struct.List* null, align 8
@vHigh = internal unnamed_addr global %struct.List* null, align 8
@max = internal unnamed_addr global %struct.List* null, align 8
@thds = internal unnamed_addr global %struct.List* null, align 8
@cores = internal unnamed_addr global %struct.List* null, align 8
@sync_lock = internal unnamed_addr global i64* null, align 8
@preempt_vector = internal unnamed_addr global i32 0, align 4

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_Parent(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !1
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !9
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: nounwind
declare void @llvm.lifetime.start(i64, i8* nocapture) #1

; Function Attrs: noredzone
declare zeroext i8 @LockSpinlock(i64*) #2

; Function Attrs: noredzone
declare zeroext i8 @UnlockSpinlock(i64*) #2

; Function Attrs: nounwind
declare void @llvm.lifetime.end(i64, i8* nocapture) #1

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_Parent(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 0
  store i64 %v, i64* %4, align 8, !tbaa !9
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_ID(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 1
  %8 = load i64, i64* %7, align 8, !tbaa !11
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_ID(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 1
  store i64 %v, i64* %4, align 8, !tbaa !11
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define %struct.ProcessInformation* @get_thread_ParentProcess(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !12
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 2
  %8 = load %struct.ProcessInformation*, %struct.ProcessInformation** %7, align 8, !tbaa !13
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret %struct.ProcessInformation* %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_ParentProcess(%struct.ThreadInfo* nocapture %t, %struct.ProcessInformation* %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 2
  store %struct.ProcessInformation* %v, %struct.ProcessInformation** %4, align 8, !tbaa !13
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_proc_ID(%struct.ProcessInformation* readonly %t) #0 {
  %1 = icmp eq %struct.ProcessInformation* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !14
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %t, i64 0, i32 10
  %5 = load i64*, i64** %4, align 8, !tbaa !15
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %t, i64 0, i32 0
  %8 = load i64, i64* %7, align 8, !tbaa !17
  %9 = load i64*, i64** %4, align 8, !tbaa !15
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_proc_PageTable(%struct.ProcessInformation* readonly %t) #0 {
  %1 = icmp eq %struct.ProcessInformation* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !18
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %t, i64 0, i32 10
  %5 = load i64*, i64** %4, align 8, !tbaa !15
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %t, i64 0, i32 6
  %8 = load i64, i64* %7, align 8, !tbaa !19
  %9 = load i64*, i64** %4, align 8, !tbaa !15
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define %struct.MemoryAllocationsMap* @get_proc_AllocationMap(%struct.ProcessInformation* readonly %t) #0 {
  %1 = icmp eq %struct.ProcessInformation* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !20
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %t, i64 0, i32 10
  %5 = load i64*, i64** %4, align 8, !tbaa !15
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %t, i64 0, i32 7
  %8 = load %struct.MemoryAllocationsMap*, %struct.MemoryAllocationsMap** %7, align 8, !tbaa !21
  %9 = load i64*, i64** %4, align 8, !tbaa !15
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret %struct.MemoryAllocationsMap* %8
}

; Function Attrs: noredzone nounwind uwtable
define void ()* @get_thread_entry_point(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !22
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 3
  %8 = load void ()*, void ()** %7, align 8, !tbaa !23
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret void ()* %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_entry_point(%struct.ThreadInfo* nocapture %t, void ()* %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 3
  store void ()* %v, void ()** %4, align 8, !tbaa !23
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @get_thread_state(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !24
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 4
  %8 = load i32, i32* %7, align 4, !tbaa !25
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i32 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_state(%struct.ThreadInfo* nocapture %t, i32 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 4
  store i32 %v, i32* %4, align 4, !tbaa !25
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @get_thread_wakeCondition(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !26
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 5
  %8 = load i32, i32* %7, align 4, !tbaa !27
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i32 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_wakeCondition(%struct.ThreadInfo* nocapture %t, i32 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 5
  store i32 %v, i32* %4, align 4, !tbaa !27
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @get_thread_priority(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !28
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 6
  %8 = load i32, i32* %7, align 4, !tbaa !29
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i32 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_priority(%struct.ThreadInfo* nocapture %t, i32 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 6
  store i32 %v, i32* %4, align 4, !tbaa !29
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_interrupt_stack_base(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !30
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 9
  %8 = load i64, i64* %7, align 8, !tbaa !31
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_interrupt_stack_base(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 9
  store i64 %v, i64* %4, align 8, !tbaa !31
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_interrupt_stack_aligned(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !32
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 14
  %8 = load i64, i64* %7, align 8, !tbaa !33
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_interrupt_stack_aligned(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 14
  store i64 %v, i64* %4, align 8, !tbaa !33
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_user_stack_base(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !34
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 11
  %8 = load i64, i64* %7, align 8, !tbaa !35
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_user_stack_base(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 11
  store i64 %v, i64* %4, align 8, !tbaa !35
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_kernel_stack_base(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !36
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 10
  %8 = load i64, i64* %7, align 8, !tbaa !37
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_kernel_stack_base(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 10
  store i64 %v, i64* %4, align 8, !tbaa !37
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_kernel_stack_aligned(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !38
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 13
  %8 = load i64, i64* %7, align 8, !tbaa !39
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_kernel_stack_aligned(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 13
  store i64 %v, i64* %4, align 8, !tbaa !39
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_current_stack(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !40
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 12
  %8 = load i64, i64* %7, align 8, !tbaa !41
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_current_stack(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 12
  store i64 %v, i64* %4, align 8, !tbaa !41
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @get_thread_core_affinity(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !42
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 15
  %8 = load i32, i32* %7, align 4, !tbaa !43
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i32 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_core_affinity(%struct.ThreadInfo* nocapture %t, i32 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 15
  store i32 %v, i32* %4, align 4, !tbaa !43
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_sleep_duration_ns(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !44
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 16
  %8 = load i64, i64* %7, align 8, !tbaa !45
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_sleep_duration_ns(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 16
  store i64 %v, i64* %4, align 8, !tbaa !45
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @get_thread_sleep_start_time(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !46
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 17
  %8 = load i64, i64* %7, align 8, !tbaa !47
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i64 %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_sleep_start_time(%struct.ThreadInfo* nocapture %t, i64 %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 17
  store i64 %v, i64* %4, align 8, !tbaa !47
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i8* @get_thread_arch_specific_data(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !48
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 21
  %8 = load i8*, i8** %7, align 8, !tbaa !49
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i8* %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_arch_specific_data(%struct.ThreadInfo* nocapture %t, i8* %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 21
  store i8* %v, i8** %4, align 8, !tbaa !49
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i8* @get_thread_fpu_state(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !50
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 20
  %8 = load i8*, i8** %7, align 8, !tbaa !51
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i8* %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_fpu_state(%struct.ThreadInfo* nocapture %t, i8* %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 20
  store i8* %v, i8** %4, align 8, !tbaa !51
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i8* @get_thread_set_child_tid(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !52
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 18
  %8 = load i8*, i8** %7, align 8, !tbaa !53
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i8* %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_set_child_tid(%struct.ThreadInfo* nocapture %t, i8* %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 18
  store i8* %v, i8** %4, align 8, !tbaa !53
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i8* @get_thread_clear_child_tid(%struct.ThreadInfo* readonly %t) #0 {
  %1 = icmp eq %struct.ThreadInfo* %t, null
  br i1 %1, label %2, label %3

; <label>:2                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !54
  br label %3

; <label>:3                                       ; preds = %2, %0
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %5 = load i64*, i64** %4, align 8, !tbaa !2
  %6 = tail call zeroext i8 @LockSpinlock(i64* %5) #4
  %7 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 19
  %8 = load i8*, i8** %7, align 8, !tbaa !55
  %9 = load i64*, i64** %4, align 8, !tbaa !2
  %10 = tail call zeroext i8 @UnlockSpinlock(i64* %9) #4
  ret i8* %8
}

; Function Attrs: noredzone nounwind uwtable
define void @set_thread_clear_child_tid(%struct.ThreadInfo* nocapture %t, i8* %v) #0 {
  %1 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 22
  %2 = load i64*, i64** %1, align 8, !tbaa !2
  %3 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %4 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %t, i64 0, i32 19
  store i8* %v, i8** %4, align 8, !tbaa !55
  %5 = load i64*, i64** %1, align 8, !tbaa !2
  %6 = tail call zeroext i8 @UnlockSpinlock(i64* %5) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i64 @GetCurrentThreadUID() #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  ret i64 %10
}

; Function Attrs: noredzone nounwind uwtable
define i64 @GetCurrentProcessUID() #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ParentProcess.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !12
  br label %get_thread_ParentProcess.exit

get_thread_ParentProcess.exit:                    ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 2
  %10 = load %struct.ProcessInformation*, %struct.ProcessInformation** %9, align 8, !tbaa !13
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %10, i64 0, i32 0
  %14 = load i64, i64* %13, align 8, !tbaa !17
  ret i64 %14
}

; Function Attrs: noredzone nounwind uwtable
define void @Thread_Initialize() #0 {
  %1 = tail call i64* @CreateSpinlock() #4
  %2 = tail call %struct.List* @List_Create(i64* %1) #4
  store %struct.List* %2, %struct.List** @vLow, align 8, !tbaa !56
  %3 = tail call i64* @CreateSpinlock() #4
  %4 = tail call %struct.List* @List_Create(i64* %3) #4
  store %struct.List* %4, %struct.List** @low, align 8, !tbaa !56
  %5 = tail call i64* @CreateSpinlock() #4
  %6 = tail call %struct.List* @List_Create(i64* %5) #4
  store %struct.List* %6, %struct.List** @medium, align 8, !tbaa !56
  %7 = tail call i64* @CreateSpinlock() #4
  %8 = tail call %struct.List* @List_Create(i64* %7) #4
  store %struct.List* %8, %struct.List** @neutral, align 8, !tbaa !56
  %9 = tail call i64* @CreateSpinlock() #4
  %10 = tail call %struct.List* @List_Create(i64* %9) #4
  store %struct.List* %10, %struct.List** @high, align 8, !tbaa !56
  %11 = tail call i64* @CreateSpinlock() #4
  %12 = tail call %struct.List* @List_Create(i64* %11) #4
  store %struct.List* %12, %struct.List** @vHigh, align 8, !tbaa !56
  %13 = tail call i64* @CreateSpinlock() #4
  %14 = tail call %struct.List* @List_Create(i64* %13) #4
  store %struct.List* %14, %struct.List** @max, align 8, !tbaa !56
  %15 = tail call i64* @CreateSpinlock() #4
  %16 = tail call %struct.List* @List_Create(i64* %15) #4
  store %struct.List* %16, %struct.List** @thds, align 8, !tbaa !56
  %17 = tail call i64* @CreateSpinlock() #4
  %18 = tail call %struct.List* @List_Create(i64* %17) #4
  store %struct.List* %18, %struct.List** @cores, align 8, !tbaa !56
  %19 = tail call i64* @CreateSpinlock() #4
  store i64* %19, i64** @sync_lock, align 8, !tbaa !56
  ret void
}

; Function Attrs: noredzone
declare %struct.List* @List_Create(i64*) #2

; Function Attrs: noredzone
declare i64* @CreateSpinlock() #2

; Function Attrs: noredzone nounwind uwtable
define i64 @CreateThread(i64 %parentProcess, void ()* %entry_point) #0 {
  %pInfo = alloca %struct.ProcessInformation*, align 8
  %user_stack_base = alloca i64, align 8
  %1 = tail call i8* @kmalloc(i64 176) #4
  %2 = tail call i64* @CreateSpinlock() #4
  %3 = getelementptr inbounds i8, i8* %1, i64 168
  %4 = bitcast i8* %3 to i64**
  store i64* %2, i64** %4, align 8, !tbaa !2
  %5 = tail call zeroext i8 @LockSpinlock(i64* %2) #4
  %6 = getelementptr inbounds i8, i8* %1, i64 24
  %7 = bitcast i8* %6 to void ()**
  store void ()* %entry_point, void ()** %7, align 8, !tbaa !23
  %8 = load i64*, i64** %4, align 8, !tbaa !2
  %9 = tail call zeroext i8 @UnlockSpinlock(i64* %8) #4
  %10 = load i64*, i64** %4, align 8, !tbaa !2
  %11 = tail call zeroext i8 @LockSpinlock(i64* %10) #4
  %12 = getelementptr inbounds i8, i8* %1, i64 32
  %13 = bitcast i8* %12 to i32*
  store i32 0, i32* %13, align 4, !tbaa !25
  %14 = load i64*, i64** %4, align 8, !tbaa !2
  %15 = tail call zeroext i8 @UnlockSpinlock(i64* %14) #4
  %16 = load i64*, i64** %4, align 8, !tbaa !2
  %17 = tail call zeroext i8 @LockSpinlock(i64* %16) #4
  %18 = getelementptr inbounds i8, i8* %1, i64 40
  %19 = bitcast i8* %18 to i32*
  store i32 3, i32* %19, align 4, !tbaa !29
  %20 = load i64*, i64** %4, align 8, !tbaa !2
  %21 = tail call zeroext i8 @UnlockSpinlock(i64* %20) #4
  %22 = load i64*, i64** %4, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = bitcast i8* %1 to i64*
  store i64 %parentProcess, i64* %24, align 8, !tbaa !9
  %25 = load i64*, i64** %4, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  %27 = load i64*, i64** %4, align 8, !tbaa !2
  %28 = tail call zeroext i8 @LockSpinlock(i64* %27) #4
  %29 = getelementptr inbounds i8, i8* %1, i64 120
  %30 = bitcast i8* %29 to i64*
  store i64 0, i64* %30, align 8, !tbaa !45
  %31 = load i64*, i64** %4, align 8, !tbaa !2
  %32 = tail call zeroext i8 @UnlockSpinlock(i64* %31) #4
  %33 = tail call i64 @GetFPUStateSize() #4
  %34 = add i64 %33, 16
  %35 = tail call i8* @kmalloc(i64 %34) #4
  %36 = load i64*, i64** %4, align 8, !tbaa !2
  %37 = tail call zeroext i8 @LockSpinlock(i64* %36) #4
  %38 = getelementptr inbounds i8, i8* %1, i64 152
  %39 = bitcast i8* %38 to i8**
  store i8* %35, i8** %39, align 8, !tbaa !51
  %40 = load i64*, i64** %4, align 8, !tbaa !2
  %41 = tail call zeroext i8 @UnlockSpinlock(i64* %40) #4
  %42 = tail call i8* @kmalloc(i64 16384) #4
  %43 = ptrtoint i8* %42 to i64
  %44 = add i64 %43, 16384
  %45 = load i64*, i64** %4, align 8, !tbaa !2
  %46 = tail call zeroext i8 @LockSpinlock(i64* %45) #4
  %47 = getelementptr inbounds i8, i8* %1, i64 64
  %48 = bitcast i8* %47 to i64*
  store i64 %44, i64* %48, align 8, !tbaa !31
  %49 = load i64*, i64** %4, align 8, !tbaa !2
  %50 = tail call zeroext i8 @UnlockSpinlock(i64* %49) #4
  %51 = tail call i8* @kmalloc(i64 16384) #4
  %52 = ptrtoint i8* %51 to i64
  %53 = add i64 %52, 16384
  %54 = load i64*, i64** %4, align 8, !tbaa !2
  %55 = tail call zeroext i8 @LockSpinlock(i64* %54) #4
  %56 = getelementptr inbounds i8, i8* %1, i64 72
  %57 = bitcast i8* %56 to i64*
  store i64 %53, i64* %57, align 8, !tbaa !37
  %58 = load i64*, i64** %4, align 8, !tbaa !2
  %59 = tail call zeroext i8 @UnlockSpinlock(i64* %58) #4
  %60 = tail call i8* @kmalloc(i64 16) #4
  %61 = load i64*, i64** %4, align 8, !tbaa !2
  %62 = tail call zeroext i8 @LockSpinlock(i64* %61) #4
  %63 = getelementptr inbounds i8, i8* %1, i64 160
  %64 = bitcast i8* %63 to i8**
  store i8* %60, i8** %64, align 8, !tbaa !49
  %65 = load i64*, i64** %4, align 8, !tbaa !2
  %66 = tail call zeroext i8 @UnlockSpinlock(i64* %65) #4
  %67 = load i64*, i64** %4, align 8, !tbaa !2
  %68 = tail call zeroext i8 @LockSpinlock(i64* %67) #4
  %69 = getelementptr inbounds i8, i8* %1, i64 144
  %70 = bitcast i8* %69 to i8**
  store i8* null, i8** %70, align 8, !tbaa !55
  %71 = load i64*, i64** %4, align 8, !tbaa !2
  %72 = tail call zeroext i8 @UnlockSpinlock(i64* %71) #4
  %73 = load i64*, i64** %4, align 8, !tbaa !2
  %74 = tail call zeroext i8 @LockSpinlock(i64* %73) #4
  %75 = getelementptr inbounds i8, i8* %1, i64 136
  %76 = bitcast i8* %75 to i8**
  store i8* null, i8** %76, align 8, !tbaa !53
  %77 = load i64*, i64** %4, align 8, !tbaa !2
  %78 = tail call zeroext i8 @UnlockSpinlock(i64* %77) #4
  %79 = icmp eq i8* %1, null
  br i1 %79, label %80, label %get_thread_kernel_stack_base.exit

; <label>:80                                      ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !36
  br label %get_thread_kernel_stack_base.exit

get_thread_kernel_stack_base.exit:                ; preds = %0, %80
  %81 = load i64*, i64** %4, align 8, !tbaa !2
  %82 = tail call zeroext i8 @LockSpinlock(i64* %81) #4
  %83 = load i64, i64* %57, align 8, !tbaa !37
  %84 = load i64*, i64** %4, align 8, !tbaa !2
  %85 = tail call zeroext i8 @UnlockSpinlock(i64* %84) #4
  %86 = and i64 %83, -16
  %87 = load i64*, i64** %4, align 8, !tbaa !2
  %88 = tail call zeroext i8 @LockSpinlock(i64* %87) #4
  %89 = getelementptr inbounds i8, i8* %1, i64 96
  %90 = bitcast i8* %89 to i64*
  store i64 %86, i64* %90, align 8, !tbaa !39
  %91 = load i64*, i64** %4, align 8, !tbaa !2
  %92 = tail call zeroext i8 @UnlockSpinlock(i64* %91) #4
  br i1 %79, label %93, label %get_thread_interrupt_stack_base.exit

; <label>:93                                      ; preds = %get_thread_kernel_stack_base.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !30
  br label %get_thread_interrupt_stack_base.exit

get_thread_interrupt_stack_base.exit:             ; preds = %get_thread_kernel_stack_base.exit, %93
  %94 = load i64*, i64** %4, align 8, !tbaa !2
  %95 = tail call zeroext i8 @LockSpinlock(i64* %94) #4
  %96 = load i64, i64* %48, align 8, !tbaa !31
  %97 = load i64*, i64** %4, align 8, !tbaa !2
  %98 = tail call zeroext i8 @UnlockSpinlock(i64* %97) #4
  %99 = and i64 %96, -16
  %100 = load i64*, i64** %4, align 8, !tbaa !2
  %101 = tail call zeroext i8 @LockSpinlock(i64* %100) #4
  %102 = getelementptr inbounds i8, i8* %1, i64 104
  %103 = bitcast i8* %102 to i64*
  store i64 %99, i64* %103, align 8, !tbaa !33
  %104 = load i64*, i64** %4, align 8, !tbaa !2
  %105 = tail call zeroext i8 @UnlockSpinlock(i64* %104) #4
  br i1 %79, label %106, label %get_thread_fpu_state.exit

; <label>:106                                     ; preds = %get_thread_interrupt_stack_base.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !50
  br label %get_thread_fpu_state.exit

get_thread_fpu_state.exit:                        ; preds = %get_thread_interrupt_stack_base.exit, %106
  %107 = load i64*, i64** %4, align 8, !tbaa !2
  %108 = tail call zeroext i8 @LockSpinlock(i64* %107) #4
  %109 = bitcast i8* %38 to i64*
  %110 = load i64, i64* %109, align 8, !tbaa !51
  %111 = load i64*, i64** %4, align 8, !tbaa !2
  %112 = tail call zeroext i8 @UnlockSpinlock(i64* %111) #4
  %113 = and i64 %110, 15
  %114 = icmp eq i64 %113, 0
  %115 = sub nsw i64 16, %113
  %116 = select i1 %114, i64 0, i64 %115
  %fpu_state_tmp.0 = add i64 %116, %110
  %117 = inttoptr i64 %fpu_state_tmp.0 to i8*
  %118 = load i64*, i64** %4, align 8, !tbaa !2
  %119 = tail call zeroext i8 @LockSpinlock(i64* %118) #4
  store i8* %117, i8** %39, align 8, !tbaa !51
  %120 = load i64*, i64** %4, align 8, !tbaa !2
  %121 = tail call zeroext i8 @UnlockSpinlock(i64* %120) #4
  br i1 %79, label %122, label %get_thread_fpu_state.exit1

; <label>:122                                     ; preds = %get_thread_fpu_state.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !50
  br label %get_thread_fpu_state.exit1

get_thread_fpu_state.exit1:                       ; preds = %get_thread_fpu_state.exit, %122
  %123 = load i64*, i64** %4, align 8, !tbaa !2
  %124 = tail call zeroext i8 @LockSpinlock(i64* %123) #4
  %125 = load i8*, i8** %39, align 8, !tbaa !51
  %126 = load i64*, i64** %4, align 8, !tbaa !2
  %127 = tail call zeroext i8 @UnlockSpinlock(i64* %126) #4
  tail call void @SaveFPUState(i8* %125) #4
  %128 = bitcast %struct.ProcessInformation** %pInfo to i8*
  call void @llvm.lifetime.start(i64 8, i8* %128) #1
  store %struct.ProcessInformation* null, %struct.ProcessInformation** %pInfo, align 8, !tbaa !56
  %129 = call i32 @GetProcessReference(i64 %parentProcess, %struct.ProcessInformation** nonnull %pInfo) #4
  %130 = icmp eq i32 %129, 2
  br i1 %130, label %247, label %get_thread_ParentProcess.exit

get_thread_ParentProcess.exit:                    ; preds = %get_thread_fpu_state.exit1
  %131 = bitcast %struct.ProcessInformation** %pInfo to i64*
  %132 = load i64, i64* %131, align 8, !tbaa !56
  %133 = load i64*, i64** %4, align 8, !tbaa !2
  %134 = call zeroext i8 @LockSpinlock(i64* %133) #4
  %135 = getelementptr inbounds i8, i8* %1, i64 16
  %136 = bitcast i8* %135 to %struct.ProcessInformation**
  %137 = bitcast i8* %135 to i64*
  store i64 %132, i64* %137, align 8, !tbaa !13
  %138 = load i64*, i64** %4, align 8, !tbaa !2
  %139 = call zeroext i8 @UnlockSpinlock(i64* %138) #4
  %140 = bitcast i64* %user_stack_base to i8*
  call void @llvm.lifetime.start(i64 8, i8* %140) #1
  store i64 0, i64* %user_stack_base, align 8, !tbaa !59
  %141 = load i64*, i64** %4, align 8, !tbaa !2
  %142 = call zeroext i8 @LockSpinlock(i64* %141) #4
  %143 = load %struct.ProcessInformation*, %struct.ProcessInformation** %136, align 8, !tbaa !13
  %144 = load i64*, i64** %4, align 8, !tbaa !2
  %145 = call zeroext i8 @UnlockSpinlock(i64* %144) #4
  %146 = icmp eq %struct.ProcessInformation* %143, null
  br i1 %146, label %147, label %get_proc_PageTable.exit

; <label>:147                                     ; preds = %get_thread_ParentProcess.exit
  call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !18
  br label %get_proc_PageTable.exit

get_proc_PageTable.exit:                          ; preds = %get_thread_ParentProcess.exit, %147
  %148 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %143, i64 0, i32 10
  %149 = load i64*, i64** %148, align 8, !tbaa !15
  %150 = call zeroext i8 @LockSpinlock(i64* %149) #4
  %151 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %143, i64 0, i32 6
  %152 = load i64, i64* %151, align 8, !tbaa !19
  %153 = load i64*, i64** %148, align 8, !tbaa !15
  %154 = call zeroext i8 @UnlockSpinlock(i64* %153) #4
  %155 = call i32 @FindFreeVirtualAddress(i64 %152, i64* nonnull %user_stack_base, i64 16384, i32 1, i32 12) #4
  %156 = load i64, i64* %user_stack_base, align 8, !tbaa !59
  %157 = icmp eq i64 %156, 0
  br i1 %157, label %.preheader.preheader, label %158

.preheader.preheader:                             ; preds = %get_proc_PageTable.exit
  br label %.preheader

.preheader:                                       ; preds = %.preheader.preheader, %.preheader
  br label %.preheader

; <label>:158                                     ; preds = %get_proc_PageTable.exit
  %159 = add i64 %156, 16256
  %160 = load i64*, i64** %4, align 8, !tbaa !2
  %161 = call zeroext i8 @LockSpinlock(i64* %160) #4
  %162 = getelementptr inbounds i8, i8* %1, i64 80
  %163 = bitcast i8* %162 to i64*
  store i64 %159, i64* %163, align 8, !tbaa !35
  %164 = load i64*, i64** %4, align 8, !tbaa !2
  %165 = call zeroext i8 @UnlockSpinlock(i64* %164) #4
  %166 = call i8* @kmalloc(i64 64) #4
  %167 = icmp eq i8* %166, null
  br i1 %167, label %.preheader8.preheader, label %get_thread_ParentProcess.exit2

.preheader8.preheader:                            ; preds = %158
  br label %.preheader8

.preheader8:                                      ; preds = %.preheader8.preheader, %.preheader8
  br label %.preheader8

get_thread_ParentProcess.exit2:                   ; preds = %158
  %168 = bitcast i8* %166 to %struct.MemoryAllocationsMap*
  %169 = load i64*, i64** %4, align 8, !tbaa !2
  %170 = call zeroext i8 @LockSpinlock(i64* %169) #4
  %171 = load %struct.ProcessInformation*, %struct.ProcessInformation** %136, align 8, !tbaa !13
  %172 = load i64*, i64** %4, align 8, !tbaa !2
  %173 = call zeroext i8 @UnlockSpinlock(i64* %172) #4
  %174 = icmp eq %struct.ProcessInformation* %171, null
  br i1 %174, label %175, label %get_thread_ParentProcess.exit4

; <label>:175                                     ; preds = %get_thread_ParentProcess.exit2
  call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !18
  br label %get_thread_ParentProcess.exit4

get_thread_ParentProcess.exit4:                   ; preds = %175, %get_thread_ParentProcess.exit2
  %176 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %171, i64 0, i32 10
  %177 = load i64*, i64** %176, align 8, !tbaa !15
  %178 = call zeroext i8 @LockSpinlock(i64* %177) #4
  %179 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %171, i64 0, i32 6
  %180 = load i64, i64* %179, align 8, !tbaa !19
  %181 = load i64*, i64** %176, align 8, !tbaa !15
  %182 = call zeroext i8 @UnlockSpinlock(i64* %181) #4
  %183 = call i64 @AllocatePhysicalPageCont(i32 4) #4
  %184 = load i64, i64* %user_stack_base, align 8, !tbaa !59
  %185 = call i32 @MapPage(i64 %180, %struct.MemoryAllocationsMap* %168, i64 %183, i64 %184, i64 16384, i32 0, i32 1, i32 12) #4
  %186 = load i64*, i64** %4, align 8, !tbaa !2
  %187 = call zeroext i8 @LockSpinlock(i64* %186) #4
  %188 = load %struct.ProcessInformation*, %struct.ProcessInformation** %136, align 8, !tbaa !13
  %189 = load i64*, i64** %4, align 8, !tbaa !2
  %190 = call zeroext i8 @UnlockSpinlock(i64* %189) #4
  %191 = icmp eq %struct.ProcessInformation* %188, null
  br i1 %191, label %192, label %get_thread_ParentProcess.exit5

; <label>:192                                     ; preds = %get_thread_ParentProcess.exit4
  call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !20
  br label %get_thread_ParentProcess.exit5

get_thread_ParentProcess.exit5:                   ; preds = %192, %get_thread_ParentProcess.exit4
  %193 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %188, i64 0, i32 10
  %194 = load i64*, i64** %193, align 8, !tbaa !15
  %195 = call zeroext i8 @LockSpinlock(i64* %194) #4
  %196 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %188, i64 0, i32 7
  %197 = load %struct.MemoryAllocationsMap*, %struct.MemoryAllocationsMap** %196, align 8, !tbaa !21
  %198 = load i64*, i64** %193, align 8, !tbaa !15
  %199 = call zeroext i8 @UnlockSpinlock(i64* %198) #4
  %200 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %197, i64 0, i32 8
  %201 = bitcast %struct.MemoryAllocationsMap** %200 to i64*
  %202 = load i64, i64* %201, align 8, !tbaa !60
  %203 = getelementptr inbounds i8, i8* %166, i64 56
  %204 = bitcast i8* %203 to i64*
  store i64 %202, i64* %204, align 8, !tbaa !60
  %205 = load i64*, i64** %4, align 8, !tbaa !2
  %206 = call zeroext i8 @LockSpinlock(i64* %205) #4
  %207 = load %struct.ProcessInformation*, %struct.ProcessInformation** %136, align 8, !tbaa !13
  %208 = load i64*, i64** %4, align 8, !tbaa !2
  %209 = call zeroext i8 @UnlockSpinlock(i64* %208) #4
  %210 = icmp eq %struct.ProcessInformation* %207, null
  br i1 %210, label %211, label %get_thread_ID.exit7

; <label>:211                                     ; preds = %get_thread_ParentProcess.exit5
  call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !20
  br label %get_thread_ID.exit7

get_thread_ID.exit7:                              ; preds = %get_thread_ParentProcess.exit5, %211
  %212 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %207, i64 0, i32 10
  %213 = load i64*, i64** %212, align 8, !tbaa !15
  %214 = call zeroext i8 @LockSpinlock(i64* %213) #4
  %215 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %207, i64 0, i32 7
  %216 = load %struct.MemoryAllocationsMap*, %struct.MemoryAllocationsMap** %215, align 8, !tbaa !21
  %217 = load i64*, i64** %212, align 8, !tbaa !15
  %218 = call zeroext i8 @UnlockSpinlock(i64* %217) #4
  %219 = getelementptr inbounds %struct.MemoryAllocationsMap, %struct.MemoryAllocationsMap* %216, i64 0, i32 8
  %220 = bitcast %struct.MemoryAllocationsMap** %219 to i8**
  store i8* %166, i8** %220, align 8, !tbaa !60
  %221 = load %struct.List*, %struct.List** @neutral, align 8, !tbaa !56
  %222 = call i32 @List_AddEntry(%struct.List* %221, i8* %1) #4
  %223 = call i64 @new_uid() #4
  %224 = load i64*, i64** %4, align 8, !tbaa !2
  %225 = call zeroext i8 @LockSpinlock(i64* %224) #4
  %226 = getelementptr inbounds i8, i8* %1, i64 8
  %227 = bitcast i8* %226 to i64*
  store i64 %223, i64* %227, align 8, !tbaa !11
  %228 = load i64*, i64** %4, align 8, !tbaa !2
  %229 = call zeroext i8 @UnlockSpinlock(i64* %228) #4
  %230 = load %struct.ProcessInformation*, %struct.ProcessInformation** %pInfo, align 8, !tbaa !56
  %231 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %230, i64 0, i32 8
  %232 = load %struct.List*, %struct.List** %231, align 8, !tbaa !62
  %233 = load i64*, i64** %4, align 8, !tbaa !2
  %234 = call zeroext i8 @LockSpinlock(i64* %233) #4
  %235 = bitcast i8* %226 to i8**
  %236 = load i8*, i8** %235, align 8, !tbaa !11
  %237 = load i64*, i64** %4, align 8, !tbaa !2
  %238 = call zeroext i8 @UnlockSpinlock(i64* %237) #4
  %239 = call i32 @List_AddEntry(%struct.List* %232, i8* %236) #4
  %240 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %241 = call i32 @List_AddEntry(%struct.List* %240, i8* %1) #4
  %242 = load i64*, i64** %4, align 8, !tbaa !2
  %243 = call zeroext i8 @LockSpinlock(i64* %242) #4
  %244 = load i64, i64* %227, align 8, !tbaa !11
  %245 = load i64*, i64** %4, align 8, !tbaa !2
  %246 = call zeroext i8 @UnlockSpinlock(i64* %245) #4
  br label %249

; <label>:247                                     ; preds = %get_thread_fpu_state.exit1
  %248 = load i64*, i64** %4, align 8, !tbaa !2
  call void @FreeSpinlock(i64* %248) #4
  call void @kfree(i8* %1) #4
  %.pre = bitcast i64* %user_stack_base to i8*
  br label %249

; <label>:249                                     ; preds = %247, %get_thread_ID.exit7
  %.pre-phi = phi i8* [ %.pre, %247 ], [ %140, %get_thread_ID.exit7 ]
  %.0 = phi i64 [ -1, %247 ], [ %244, %get_thread_ID.exit7 ]
  call void @llvm.lifetime.end(i64 8, i8* %.pre-phi) #1
  call void @llvm.lifetime.end(i64 8, i8* %128) #1
  ret i64 %.0
}

; Function Attrs: noredzone
declare i8* @kmalloc(i64) #2

; Function Attrs: noredzone
declare i64 @GetFPUStateSize() #2

; Function Attrs: noredzone
declare void @SaveFPUState(i8*) #2

; Function Attrs: noredzone
declare i32 @GetProcessReference(i64, %struct.ProcessInformation**) #2

; Function Attrs: noredzone
declare i32 @FindFreeVirtualAddress(i64, i64*, i64, i32, i32) #2

; Function Attrs: noredzone
declare i32 @MapPage(i64, %struct.MemoryAllocationsMap*, i64, i64, i64, i32, i32, i32) #2

; Function Attrs: noredzone
declare i64 @AllocatePhysicalPageCont(i32) #2

; Function Attrs: noredzone
declare i32 @List_AddEntry(%struct.List*, i8*) #2

; Function Attrs: noredzone
declare i64 @new_uid() #2

; Function Attrs: noredzone
declare void @FreeSpinlock(i64*) #2

; Function Attrs: noredzone
declare void @kfree(i8*) #2

; Function Attrs: noredzone nounwind uwtable
define void @Thread_SetChildTIDAddress(i64 %id, i8* %address) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %22 = load i64*, i64** %21, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 18
  store i8* %address, i8** %24, align 8, !tbaa !53
  %25 = load i64*, i64** %21, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  br label %.loopexit

; <label>:27                                      ; preds = %get_thread_ID.exit2
  %28 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %29 = tail call i64 @List_Length(%struct.List* %28) #4
  %30 = icmp ult i64 %45, %29
  br i1 %30, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %27
  %i.04 = phi i64 [ %45, %27 ], [ 0, %.lr.ph.preheader ]
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i8* @List_EntryAt(%struct.List* %31, i64 %i.04) #4
  %33 = icmp eq i8* %32, null
  br i1 %33, label %34, label %get_thread_ID.exit2

; <label>:34                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit2

get_thread_ID.exit2:                              ; preds = %.lr.ph, %34
  %35 = getelementptr inbounds i8, i8* %32, i64 168
  %36 = bitcast i8* %35 to i64**
  %37 = load i64*, i64** %36, align 8, !tbaa !2
  %38 = tail call zeroext i8 @LockSpinlock(i64* %37) #4
  %39 = getelementptr inbounds i8, i8* %32, i64 8
  %40 = bitcast i8* %39 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !11
  %42 = load i64*, i64** %36, align 8, !tbaa !2
  %43 = tail call zeroext i8 @UnlockSpinlock(i64* %42) #4
  %44 = icmp eq i64 %41, %id
  %45 = add i64 %i.04, 1
  br i1 %44, label %.critedge, label %27

.critedge:                                        ; preds = %get_thread_ID.exit2
  %.lcssa17 = phi i64** [ %36, %get_thread_ID.exit2 ]
  %.lcssa = phi i8* [ %32, %get_thread_ID.exit2 ]
  %46 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %47 = tail call zeroext i8 @LockSpinlock(i64* %46) #4
  %48 = getelementptr inbounds i8, i8* %.lcssa, i64 136
  %49 = bitcast i8* %48 to i8**
  store i8* %address, i8** %49, align 8, !tbaa !53
  %50 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %51 = tail call zeroext i8 @UnlockSpinlock(i64* %50) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %27
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %.critedge, %17
  ret void
}

; Function Attrs: noredzone
declare i64 @List_Length(%struct.List*) #2

; Function Attrs: noredzone
declare i8* @List_EntryAt(%struct.List*, i64) #2

; Function Attrs: noredzone nounwind uwtable
define void @Thread_SetClearChildTIDAddress(i64 %id, i8* %address) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %22 = load i64*, i64** %21, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 19
  store i8* %address, i8** %24, align 8, !tbaa !55
  %25 = load i64*, i64** %21, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  br label %.loopexit

; <label>:27                                      ; preds = %get_thread_ID.exit2
  %28 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %29 = tail call i64 @List_Length(%struct.List* %28) #4
  %30 = icmp ult i64 %45, %29
  br i1 %30, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %27
  %i.04 = phi i64 [ %45, %27 ], [ 0, %.lr.ph.preheader ]
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i8* @List_EntryAt(%struct.List* %31, i64 %i.04) #4
  %33 = icmp eq i8* %32, null
  br i1 %33, label %34, label %get_thread_ID.exit2

; <label>:34                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit2

get_thread_ID.exit2:                              ; preds = %.lr.ph, %34
  %35 = getelementptr inbounds i8, i8* %32, i64 168
  %36 = bitcast i8* %35 to i64**
  %37 = load i64*, i64** %36, align 8, !tbaa !2
  %38 = tail call zeroext i8 @LockSpinlock(i64* %37) #4
  %39 = getelementptr inbounds i8, i8* %32, i64 8
  %40 = bitcast i8* %39 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !11
  %42 = load i64*, i64** %36, align 8, !tbaa !2
  %43 = tail call zeroext i8 @UnlockSpinlock(i64* %42) #4
  %44 = icmp eq i64 %41, %id
  %45 = add i64 %i.04, 1
  br i1 %44, label %.critedge, label %27

.critedge:                                        ; preds = %get_thread_ID.exit2
  %.lcssa17 = phi i64** [ %36, %get_thread_ID.exit2 ]
  %.lcssa = phi i8* [ %32, %get_thread_ID.exit2 ]
  %46 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %47 = tail call zeroext i8 @LockSpinlock(i64* %46) #4
  %48 = getelementptr inbounds i8, i8* %.lcssa, i64 144
  %49 = bitcast i8* %48 to i8**
  store i8* %address, i8** %49, align 8, !tbaa !55
  %50 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %51 = tail call zeroext i8 @UnlockSpinlock(i64* %50) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %27
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %.critedge, %17
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define void @SetThreadState(i64 %id, i32 %state) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %22 = load i64*, i64** %21, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 4
  store i32 %state, i32* %24, align 4, !tbaa !25
  %25 = load i64*, i64** %21, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  br label %.loopexit

; <label>:27                                      ; preds = %get_thread_ID.exit2
  %28 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %29 = tail call i64 @List_Length(%struct.List* %28) #4
  %30 = icmp ult i64 %45, %29
  br i1 %30, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %27
  %i.04 = phi i64 [ %45, %27 ], [ 0, %.lr.ph.preheader ]
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i8* @List_EntryAt(%struct.List* %31, i64 %i.04) #4
  %33 = icmp eq i8* %32, null
  br i1 %33, label %34, label %get_thread_ID.exit2

; <label>:34                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit2

get_thread_ID.exit2:                              ; preds = %.lr.ph, %34
  %35 = getelementptr inbounds i8, i8* %32, i64 168
  %36 = bitcast i8* %35 to i64**
  %37 = load i64*, i64** %36, align 8, !tbaa !2
  %38 = tail call zeroext i8 @LockSpinlock(i64* %37) #4
  %39 = getelementptr inbounds i8, i8* %32, i64 8
  %40 = bitcast i8* %39 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !11
  %42 = load i64*, i64** %36, align 8, !tbaa !2
  %43 = tail call zeroext i8 @UnlockSpinlock(i64* %42) #4
  %44 = icmp eq i64 %41, %id
  %45 = add i64 %i.04, 1
  br i1 %44, label %.critedge, label %27

.critedge:                                        ; preds = %get_thread_ID.exit2
  %.lcssa17 = phi i64** [ %36, %get_thread_ID.exit2 ]
  %.lcssa = phi i8* [ %32, %get_thread_ID.exit2 ]
  %46 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %47 = tail call zeroext i8 @LockSpinlock(i64* %46) #4
  %48 = getelementptr inbounds i8, i8* %.lcssa, i64 32
  %49 = bitcast i8* %48 to i32*
  store i32 %state, i32* %49, align 4, !tbaa !25
  %50 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %51 = tail call zeroext i8 @UnlockSpinlock(i64* %50) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %27
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %.critedge, %17
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define void @SleepThread(i64 %id, i64 %duration_ms) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %22 = load i64*, i64** %21, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 4
  store i32 3, i32* %24, align 4, !tbaa !25
  %25 = load i64*, i64** %21, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  %27 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %28 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %27, i64 0, i32 0
  %29 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %28, align 8, !tbaa !57
  %30 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %29, i64 0, i32 22
  %31 = load i64*, i64** %30, align 8, !tbaa !2
  %32 = tail call zeroext i8 @LockSpinlock(i64* %31) #4
  %33 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %29, i64 0, i32 5
  store i32 1, i32* %33, align 4, !tbaa !27
  %34 = load i64*, i64** %30, align 8, !tbaa !2
  %35 = tail call zeroext i8 @UnlockSpinlock(i64* %34) #4
  %36 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %37 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %36, i64 0, i32 0
  %38 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %37, align 8, !tbaa !57
  %39 = tail call i64 @GetTimerValue() #4
  %40 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %38, i64 0, i32 22
  %41 = load i64*, i64** %40, align 8, !tbaa !2
  %42 = tail call zeroext i8 @LockSpinlock(i64* %41) #4
  %43 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %38, i64 0, i32 17
  store i64 %39, i64* %43, align 8, !tbaa !47
  %44 = load i64*, i64** %40, align 8, !tbaa !2
  %45 = tail call zeroext i8 @UnlockSpinlock(i64* %44) #4
  %46 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %47 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %46, i64 0, i32 0
  %48 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %47, align 8, !tbaa !57
  %49 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %48, i64 0, i32 22
  %50 = load i64*, i64** %49, align 8, !tbaa !2
  %51 = tail call zeroext i8 @LockSpinlock(i64* %50) #4
  %52 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %48, i64 0, i32 16
  store i64 %duration_ms, i64* %52, align 8, !tbaa !45
  %53 = load i64*, i64** %49, align 8, !tbaa !2
  %54 = tail call zeroext i8 @UnlockSpinlock(i64* %53) #4
  %55 = load i32, i32* @preempt_vector, align 4, !tbaa !63
  tail call void @RaiseInterrupt(i32 %55) #4
  br label %.loopexit

; <label>:56                                      ; preds = %get_thread_ID.exit2
  %57 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %58 = tail call i64 @List_Length(%struct.List* %57) #4
  %59 = icmp ult i64 %74, %58
  br i1 %59, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %56
  %i.04 = phi i64 [ %74, %56 ], [ 0, %.lr.ph.preheader ]
  %60 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %61 = tail call i8* @List_EntryAt(%struct.List* %60, i64 %i.04) #4
  %62 = icmp eq i8* %61, null
  br i1 %62, label %63, label %get_thread_ID.exit2

; <label>:63                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit2

get_thread_ID.exit2:                              ; preds = %.lr.ph, %63
  %64 = getelementptr inbounds i8, i8* %61, i64 168
  %65 = bitcast i8* %64 to i64**
  %66 = load i64*, i64** %65, align 8, !tbaa !2
  %67 = tail call zeroext i8 @LockSpinlock(i64* %66) #4
  %68 = getelementptr inbounds i8, i8* %61, i64 8
  %69 = bitcast i8* %68 to i64*
  %70 = load i64, i64* %69, align 8, !tbaa !11
  %71 = load i64*, i64** %65, align 8, !tbaa !2
  %72 = tail call zeroext i8 @UnlockSpinlock(i64* %71) #4
  %73 = icmp eq i64 %70, %id
  %74 = add i64 %i.04, 1
  br i1 %73, label %.critedge, label %56

.critedge:                                        ; preds = %get_thread_ID.exit2
  %.lcssa17 = phi i64** [ %65, %get_thread_ID.exit2 ]
  %.lcssa = phi i8* [ %61, %get_thread_ID.exit2 ]
  %75 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %76 = tail call zeroext i8 @LockSpinlock(i64* %75) #4
  %77 = getelementptr inbounds i8, i8* %.lcssa, i64 32
  %78 = bitcast i8* %77 to i32*
  store i32 3, i32* %78, align 4, !tbaa !25
  %79 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %80 = tail call zeroext i8 @UnlockSpinlock(i64* %79) #4
  %81 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %82 = tail call zeroext i8 @LockSpinlock(i64* %81) #4
  %83 = getelementptr inbounds i8, i8* %.lcssa, i64 36
  %84 = bitcast i8* %83 to i32*
  store i32 1, i32* %84, align 4, !tbaa !27
  %85 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %86 = tail call zeroext i8 @UnlockSpinlock(i64* %85) #4
  %87 = tail call i64 @GetTimerValue() #4
  %88 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %89 = tail call zeroext i8 @LockSpinlock(i64* %88) #4
  %90 = getelementptr inbounds i8, i8* %.lcssa, i64 128
  %91 = bitcast i8* %90 to i64*
  store i64 %87, i64* %91, align 8, !tbaa !47
  %92 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %93 = tail call zeroext i8 @UnlockSpinlock(i64* %92) #4
  %94 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %95 = tail call zeroext i8 @LockSpinlock(i64* %94) #4
  %96 = getelementptr inbounds i8, i8* %.lcssa, i64 120
  %97 = bitcast i8* %96 to i64*
  store i64 %duration_ms, i64* %97, align 8, !tbaa !45
  %98 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %99 = tail call zeroext i8 @UnlockSpinlock(i64* %98) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %56
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %.critedge, %17
  ret void
}

; Function Attrs: noredzone
declare i64 @GetTimerValue() #2

; Function Attrs: noredzone nounwind uwtable
define void @YieldThread() #0 {
  %1 = load i32, i32* @preempt_vector, align 4, !tbaa !63
  tail call void @RaiseInterrupt(i32 %1) #4
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @GetThreadState(i64 %id) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = icmp eq %struct.ThreadInfo* %20, null
  br i1 %21, label %22, label %get_thread_state.exit

; <label>:22                                      ; preds = %17
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !24
  br label %get_thread_state.exit

get_thread_state.exit:                            ; preds = %17, %22
  %23 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %24 = load i64*, i64** %23, align 8, !tbaa !2
  %25 = tail call zeroext i8 @LockSpinlock(i64* %24) #4
  %26 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 4
  %27 = load i32, i32* %26, align 4, !tbaa !25
  %28 = load i64*, i64** %23, align 8, !tbaa !2
  %29 = tail call zeroext i8 @UnlockSpinlock(i64* %28) #4
  ret i32 %27

; <label>:30                                      ; preds = %get_thread_ID.exit4
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i64 @List_Length(%struct.List* %31) #4
  %33 = icmp ult i64 %48, %32
  br i1 %33, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %30
  %i.09 = phi i64 [ %48, %30 ], [ 0, %.lr.ph.preheader ]
  %34 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %35 = tail call i8* @List_EntryAt(%struct.List* %34, i64 %i.09) #4
  %36 = icmp eq i8* %35, null
  br i1 %36, label %37, label %get_thread_ID.exit4

; <label>:37                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit4

get_thread_ID.exit4:                              ; preds = %.lr.ph, %37
  %38 = getelementptr inbounds i8, i8* %35, i64 168
  %39 = bitcast i8* %38 to i64**
  %40 = load i64*, i64** %39, align 8, !tbaa !2
  %41 = tail call zeroext i8 @LockSpinlock(i64* %40) #4
  %42 = getelementptr inbounds i8, i8* %35, i64 8
  %43 = bitcast i8* %42 to i64*
  %44 = load i64, i64* %43, align 8, !tbaa !11
  %45 = load i64*, i64** %39, align 8, !tbaa !2
  %46 = tail call zeroext i8 @UnlockSpinlock(i64* %45) #4
  %47 = icmp eq i64 %44, %id
  %48 = add i64 %i.09, 1
  br i1 %47, label %49, label %30

; <label>:49                                      ; preds = %get_thread_ID.exit4
  %.lcssa31 = phi i64** [ %39, %get_thread_ID.exit4 ]
  %.lcssa = phi i8* [ %35, %get_thread_ID.exit4 ]
  %50 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %51 = tail call zeroext i8 @LockSpinlock(i64* %50) #4
  %52 = getelementptr inbounds i8, i8* %.lcssa, i64 32
  %53 = bitcast i8* %52 to i32*
  %54 = load i32, i32* %53, align 4, !tbaa !25
  %55 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %56 = tail call zeroext i8 @UnlockSpinlock(i64* %55) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %30
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %49
  %.13 = phi i32 [ %54, %49 ], [ -1, %.preheader ], [ -1, %.loopexit.loopexit ]
  ret i32 %.13
}

; Function Attrs: noredzone nounwind uwtable
define i8* @GetThreadUserStack(i64 %id) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = icmp eq %struct.ThreadInfo* %20, null
  br i1 %21, label %22, label %get_thread_user_stack_base.exit

; <label>:22                                      ; preds = %17
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !34
  br label %get_thread_user_stack_base.exit

get_thread_user_stack_base.exit:                  ; preds = %17, %22
  %23 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %24 = load i64*, i64** %23, align 8, !tbaa !2
  %25 = tail call zeroext i8 @LockSpinlock(i64* %24) #4
  %26 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 11
  %27 = bitcast i64* %26 to i8**
  %28 = load i8*, i8** %27, align 8, !tbaa !35
  %29 = load i64*, i64** %23, align 8, !tbaa !2
  %30 = tail call zeroext i8 @UnlockSpinlock(i64* %29) #4
  ret i8* %28

; <label>:31                                      ; preds = %get_thread_ID.exit4
  %32 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %33 = tail call i64 @List_Length(%struct.List* %32) #4
  %34 = icmp ult i64 %49, %33
  br i1 %34, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %31
  %i.09 = phi i64 [ %49, %31 ], [ 0, %.lr.ph.preheader ]
  %35 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %36 = tail call i8* @List_EntryAt(%struct.List* %35, i64 %i.09) #4
  %37 = icmp eq i8* %36, null
  br i1 %37, label %38, label %get_thread_ID.exit4

; <label>:38                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit4

get_thread_ID.exit4:                              ; preds = %.lr.ph, %38
  %39 = getelementptr inbounds i8, i8* %36, i64 168
  %40 = bitcast i8* %39 to i64**
  %41 = load i64*, i64** %40, align 8, !tbaa !2
  %42 = tail call zeroext i8 @LockSpinlock(i64* %41) #4
  %43 = getelementptr inbounds i8, i8* %36, i64 8
  %44 = bitcast i8* %43 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !11
  %46 = load i64*, i64** %40, align 8, !tbaa !2
  %47 = tail call zeroext i8 @UnlockSpinlock(i64* %46) #4
  %48 = icmp eq i64 %45, %id
  %49 = add i64 %i.09, 1
  br i1 %48, label %50, label %31

; <label>:50                                      ; preds = %get_thread_ID.exit4
  %.lcssa31 = phi i64** [ %40, %get_thread_ID.exit4 ]
  %.lcssa = phi i8* [ %36, %get_thread_ID.exit4 ]
  %51 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %52 = tail call zeroext i8 @LockSpinlock(i64* %51) #4
  %53 = getelementptr inbounds i8, i8* %.lcssa, i64 80
  %54 = bitcast i8* %53 to i8**
  %55 = load i8*, i8** %54, align 8, !tbaa !35
  %56 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %57 = tail call zeroext i8 @UnlockSpinlock(i64* %56) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %31
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %50
  %.13 = phi i8* [ %55, %50 ], [ null, %.preheader ], [ null, %.loopexit.loopexit ]
  ret i8* %.13
}

; Function Attrs: noredzone nounwind uwtable
define i8* @GetThreadKernelStack(i64 %id) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = icmp eq %struct.ThreadInfo* %20, null
  br i1 %21, label %22, label %get_thread_kernel_stack_aligned.exit

; <label>:22                                      ; preds = %17
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !38
  br label %get_thread_kernel_stack_aligned.exit

get_thread_kernel_stack_aligned.exit:             ; preds = %17, %22
  %23 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %24 = load i64*, i64** %23, align 8, !tbaa !2
  %25 = tail call zeroext i8 @LockSpinlock(i64* %24) #4
  %26 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 13
  %27 = bitcast i64* %26 to i8**
  %28 = load i8*, i8** %27, align 8, !tbaa !39
  %29 = load i64*, i64** %23, align 8, !tbaa !2
  %30 = tail call zeroext i8 @UnlockSpinlock(i64* %29) #4
  ret i8* %28

; <label>:31                                      ; preds = %get_thread_ID.exit4
  %32 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %33 = tail call i64 @List_Length(%struct.List* %32) #4
  %34 = icmp ult i64 %49, %33
  br i1 %34, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %31
  %i.09 = phi i64 [ %49, %31 ], [ 0, %.lr.ph.preheader ]
  %35 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %36 = tail call i8* @List_EntryAt(%struct.List* %35, i64 %i.09) #4
  %37 = icmp eq i8* %36, null
  br i1 %37, label %38, label %get_thread_ID.exit4

; <label>:38                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit4

get_thread_ID.exit4:                              ; preds = %.lr.ph, %38
  %39 = getelementptr inbounds i8, i8* %36, i64 168
  %40 = bitcast i8* %39 to i64**
  %41 = load i64*, i64** %40, align 8, !tbaa !2
  %42 = tail call zeroext i8 @LockSpinlock(i64* %41) #4
  %43 = getelementptr inbounds i8, i8* %36, i64 8
  %44 = bitcast i8* %43 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !11
  %46 = load i64*, i64** %40, align 8, !tbaa !2
  %47 = tail call zeroext i8 @UnlockSpinlock(i64* %46) #4
  %48 = icmp eq i64 %45, %id
  %49 = add i64 %i.09, 1
  br i1 %48, label %50, label %31

; <label>:50                                      ; preds = %get_thread_ID.exit4
  %.lcssa31 = phi i64** [ %40, %get_thread_ID.exit4 ]
  %.lcssa = phi i8* [ %36, %get_thread_ID.exit4 ]
  %51 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %52 = tail call zeroext i8 @LockSpinlock(i64* %51) #4
  %53 = getelementptr inbounds i8, i8* %.lcssa, i64 96
  %54 = bitcast i8* %53 to i8**
  %55 = load i8*, i8** %54, align 8, !tbaa !39
  %56 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %57 = tail call zeroext i8 @UnlockSpinlock(i64* %56) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %31
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %50
  %.13 = phi i8* [ %55, %50 ], [ null, %.preheader ], [ null, %.loopexit.loopexit ]
  ret i8* %.13
}

; Function Attrs: noredzone nounwind uwtable
define i8* @GetThreadCurrentStack(i64 %id) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = icmp eq %struct.ThreadInfo* %20, null
  br i1 %21, label %22, label %get_thread_current_stack.exit

; <label>:22                                      ; preds = %17
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !40
  br label %get_thread_current_stack.exit

get_thread_current_stack.exit:                    ; preds = %17, %22
  %23 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %24 = load i64*, i64** %23, align 8, !tbaa !2
  %25 = tail call zeroext i8 @LockSpinlock(i64* %24) #4
  %26 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 12
  %27 = bitcast i64* %26 to i8**
  %28 = load i8*, i8** %27, align 8, !tbaa !41
  %29 = load i64*, i64** %23, align 8, !tbaa !2
  %30 = tail call zeroext i8 @UnlockSpinlock(i64* %29) #4
  ret i8* %28

; <label>:31                                      ; preds = %get_thread_ID.exit4
  %32 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %33 = tail call i64 @List_Length(%struct.List* %32) #4
  %34 = icmp ult i64 %49, %33
  br i1 %34, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %31
  %i.09 = phi i64 [ %49, %31 ], [ 0, %.lr.ph.preheader ]
  %35 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %36 = tail call i8* @List_EntryAt(%struct.List* %35, i64 %i.09) #4
  %37 = icmp eq i8* %36, null
  br i1 %37, label %38, label %get_thread_ID.exit4

; <label>:38                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit4

get_thread_ID.exit4:                              ; preds = %.lr.ph, %38
  %39 = getelementptr inbounds i8, i8* %36, i64 168
  %40 = bitcast i8* %39 to i64**
  %41 = load i64*, i64** %40, align 8, !tbaa !2
  %42 = tail call zeroext i8 @LockSpinlock(i64* %41) #4
  %43 = getelementptr inbounds i8, i8* %36, i64 8
  %44 = bitcast i8* %43 to i64*
  %45 = load i64, i64* %44, align 8, !tbaa !11
  %46 = load i64*, i64** %40, align 8, !tbaa !2
  %47 = tail call zeroext i8 @UnlockSpinlock(i64* %46) #4
  %48 = icmp eq i64 %45, %id
  %49 = add i64 %i.09, 1
  br i1 %48, label %50, label %31

; <label>:50                                      ; preds = %get_thread_ID.exit4
  %.lcssa31 = phi i64** [ %40, %get_thread_ID.exit4 ]
  %.lcssa = phi i8* [ %36, %get_thread_ID.exit4 ]
  %51 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %52 = tail call zeroext i8 @LockSpinlock(i64* %51) #4
  %53 = getelementptr inbounds i8, i8* %.lcssa, i64 88
  %54 = bitcast i8* %53 to i8**
  %55 = load i8*, i8** %54, align 8, !tbaa !41
  %56 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %57 = tail call zeroext i8 @UnlockSpinlock(i64* %56) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %31
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %50
  %.13 = phi i8* [ %55, %50 ], [ null, %.preheader ], [ null, %.loopexit.loopexit ]
  ret i8* %.13
}

; Function Attrs: noredzone nounwind uwtable
define void @SetThreadBasePriority(i64 %id, i32 %priority) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %22 = load i64*, i64** %21, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 6
  store i32 %priority, i32* %24, align 4, !tbaa !29
  %25 = load i64*, i64** %21, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  br label %.loopexit

; <label>:27                                      ; preds = %get_thread_ID.exit2
  %28 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %29 = tail call i64 @List_Length(%struct.List* %28) #4
  %30 = icmp ult i64 %45, %29
  br i1 %30, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %27
  %i.04 = phi i64 [ %45, %27 ], [ 0, %.lr.ph.preheader ]
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i8* @List_EntryAt(%struct.List* %31, i64 %i.04) #4
  %33 = icmp eq i8* %32, null
  br i1 %33, label %34, label %get_thread_ID.exit2

; <label>:34                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit2

get_thread_ID.exit2:                              ; preds = %.lr.ph, %34
  %35 = getelementptr inbounds i8, i8* %32, i64 168
  %36 = bitcast i8* %35 to i64**
  %37 = load i64*, i64** %36, align 8, !tbaa !2
  %38 = tail call zeroext i8 @LockSpinlock(i64* %37) #4
  %39 = getelementptr inbounds i8, i8* %32, i64 8
  %40 = bitcast i8* %39 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !11
  %42 = load i64*, i64** %36, align 8, !tbaa !2
  %43 = tail call zeroext i8 @UnlockSpinlock(i64* %42) #4
  %44 = icmp eq i64 %41, %id
  %45 = add i64 %i.04, 1
  br i1 %44, label %.critedge, label %27

.critedge:                                        ; preds = %get_thread_ID.exit2
  %.lcssa17 = phi i64** [ %36, %get_thread_ID.exit2 ]
  %.lcssa = phi i8* [ %32, %get_thread_ID.exit2 ]
  %46 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %47 = tail call zeroext i8 @LockSpinlock(i64* %46) #4
  %48 = getelementptr inbounds i8, i8* %.lcssa, i64 40
  %49 = bitcast i8* %48 to i32*
  store i32 %priority, i32* %49, align 4, !tbaa !29
  %50 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %51 = tail call zeroext i8 @UnlockSpinlock(i64* %50) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %27
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %.critedge, %17
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @GetThreadPriority(i64 %id) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = icmp eq %struct.ThreadInfo* %20, null
  br i1 %21, label %22, label %get_thread_priority.exit

; <label>:22                                      ; preds = %17
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !28
  br label %get_thread_priority.exit

get_thread_priority.exit:                         ; preds = %17, %22
  %23 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %24 = load i64*, i64** %23, align 8, !tbaa !2
  %25 = tail call zeroext i8 @LockSpinlock(i64* %24) #4
  %26 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 6
  %27 = load i32, i32* %26, align 4, !tbaa !29
  %28 = load i64*, i64** %23, align 8, !tbaa !2
  %29 = tail call zeroext i8 @UnlockSpinlock(i64* %28) #4
  ret i32 %27

; <label>:30                                      ; preds = %get_thread_ID.exit4
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i64 @List_Length(%struct.List* %31) #4
  %33 = icmp ult i64 %48, %32
  br i1 %33, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %30
  %i.09 = phi i64 [ %48, %30 ], [ 0, %.lr.ph.preheader ]
  %34 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %35 = tail call i8* @List_EntryAt(%struct.List* %34, i64 %i.09) #4
  %36 = icmp eq i8* %35, null
  br i1 %36, label %37, label %get_thread_ID.exit4

; <label>:37                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit4

get_thread_ID.exit4:                              ; preds = %.lr.ph, %37
  %38 = getelementptr inbounds i8, i8* %35, i64 168
  %39 = bitcast i8* %38 to i64**
  %40 = load i64*, i64** %39, align 8, !tbaa !2
  %41 = tail call zeroext i8 @LockSpinlock(i64* %40) #4
  %42 = getelementptr inbounds i8, i8* %35, i64 8
  %43 = bitcast i8* %42 to i64*
  %44 = load i64, i64* %43, align 8, !tbaa !11
  %45 = load i64*, i64** %39, align 8, !tbaa !2
  %46 = tail call zeroext i8 @UnlockSpinlock(i64* %45) #4
  %47 = icmp eq i64 %44, %id
  %48 = add i64 %i.09, 1
  br i1 %47, label %49, label %30

; <label>:49                                      ; preds = %get_thread_ID.exit4
  %.lcssa31 = phi i64** [ %39, %get_thread_ID.exit4 ]
  %.lcssa = phi i8* [ %35, %get_thread_ID.exit4 ]
  %50 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %51 = tail call zeroext i8 @LockSpinlock(i64* %50) #4
  %52 = getelementptr inbounds i8, i8* %.lcssa, i64 40
  %53 = bitcast i8* %52 to i32*
  %54 = load i32, i32* %53, align 4, !tbaa !29
  %55 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %56 = tail call zeroext i8 @UnlockSpinlock(i64* %55) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %30
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %49
  %.13 = phi i32 [ %54, %49 ], [ -1, %.preheader ], [ -1, %.loopexit.loopexit ]
  ret i32 %.13
}

; Function Attrs: noredzone nounwind uwtable
define void @SetThreadCoreAffinity(i64 %id, i32 %coreID) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %22 = load i64*, i64** %21, align 8, !tbaa !2
  %23 = tail call zeroext i8 @LockSpinlock(i64* %22) #4
  %24 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 15
  store i32 %coreID, i32* %24, align 4, !tbaa !43
  %25 = load i64*, i64** %21, align 8, !tbaa !2
  %26 = tail call zeroext i8 @UnlockSpinlock(i64* %25) #4
  br label %.loopexit

; <label>:27                                      ; preds = %get_thread_ID.exit2
  %28 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %29 = tail call i64 @List_Length(%struct.List* %28) #4
  %30 = icmp ult i64 %45, %29
  br i1 %30, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %27
  %i.04 = phi i64 [ %45, %27 ], [ 0, %.lr.ph.preheader ]
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i8* @List_EntryAt(%struct.List* %31, i64 %i.04) #4
  %33 = icmp eq i8* %32, null
  br i1 %33, label %34, label %get_thread_ID.exit2

; <label>:34                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit2

get_thread_ID.exit2:                              ; preds = %.lr.ph, %34
  %35 = getelementptr inbounds i8, i8* %32, i64 168
  %36 = bitcast i8* %35 to i64**
  %37 = load i64*, i64** %36, align 8, !tbaa !2
  %38 = tail call zeroext i8 @LockSpinlock(i64* %37) #4
  %39 = getelementptr inbounds i8, i8* %32, i64 8
  %40 = bitcast i8* %39 to i64*
  %41 = load i64, i64* %40, align 8, !tbaa !11
  %42 = load i64*, i64** %36, align 8, !tbaa !2
  %43 = tail call zeroext i8 @UnlockSpinlock(i64* %42) #4
  %44 = icmp eq i64 %41, %id
  %45 = add i64 %i.04, 1
  br i1 %44, label %.critedge, label %27

.critedge:                                        ; preds = %get_thread_ID.exit2
  %.lcssa17 = phi i64** [ %36, %get_thread_ID.exit2 ]
  %.lcssa = phi i8* [ %32, %get_thread_ID.exit2 ]
  %46 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %47 = tail call zeroext i8 @LockSpinlock(i64* %46) #4
  %48 = getelementptr inbounds i8, i8* %.lcssa, i64 112
  %49 = bitcast i8* %48 to i32*
  store i32 %coreID, i32* %49, align 4, !tbaa !43
  %50 = load i64*, i64** %.lcssa17, align 8, !tbaa !2
  %51 = tail call zeroext i8 @UnlockSpinlock(i64* %50) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %27
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %.critedge, %17
  ret void
}

; Function Attrs: noredzone nounwind uwtable
define i32 @GetThreadCoreAffinity(i64 %id) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_ID.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit

get_thread_ID.exit:                               ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 1
  %10 = load i64, i64* %9, align 8, !tbaa !11
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  %13 = icmp eq i64 %10, %id
  br i1 %13, label %17, label %.preheader

.preheader:                                       ; preds = %get_thread_ID.exit
  %14 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %15 = tail call i64 @List_Length(%struct.List* %14) #4
  %16 = icmp eq i64 %15, 0
  br i1 %16, label %.loopexit, label %.lr.ph.preheader

.lr.ph.preheader:                                 ; preds = %.preheader
  br label %.lr.ph

; <label>:17                                      ; preds = %get_thread_ID.exit
  %18 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %19 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %18, i64 0, i32 0
  %20 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %19, align 8, !tbaa !57
  %21 = icmp eq %struct.ThreadInfo* %20, null
  br i1 %21, label %22, label %get_thread_core_affinity.exit

; <label>:22                                      ; preds = %17
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !42
  br label %get_thread_core_affinity.exit

get_thread_core_affinity.exit:                    ; preds = %17, %22
  %23 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 22
  %24 = load i64*, i64** %23, align 8, !tbaa !2
  %25 = tail call zeroext i8 @LockSpinlock(i64* %24) #4
  %26 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %20, i64 0, i32 15
  %27 = load i32, i32* %26, align 4, !tbaa !43
  %28 = load i64*, i64** %23, align 8, !tbaa !2
  %29 = tail call zeroext i8 @UnlockSpinlock(i64* %28) #4
  ret i32 %27

; <label>:30                                      ; preds = %get_thread_ID.exit4
  %31 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %32 = tail call i64 @List_Length(%struct.List* %31) #4
  %33 = icmp ult i64 %48, %32
  br i1 %33, label %.lr.ph, label %.loopexit.loopexit

.lr.ph:                                           ; preds = %.lr.ph.preheader, %30
  %i.09 = phi i64 [ %48, %30 ], [ 0, %.lr.ph.preheader ]
  %34 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %35 = tail call i8* @List_EntryAt(%struct.List* %34, i64 %i.09) #4
  %36 = icmp eq i8* %35, null
  br i1 %36, label %37, label %get_thread_ID.exit4

; <label>:37                                      ; preds = %.lr.ph
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !10
  br label %get_thread_ID.exit4

get_thread_ID.exit4:                              ; preds = %.lr.ph, %37
  %38 = getelementptr inbounds i8, i8* %35, i64 168
  %39 = bitcast i8* %38 to i64**
  %40 = load i64*, i64** %39, align 8, !tbaa !2
  %41 = tail call zeroext i8 @LockSpinlock(i64* %40) #4
  %42 = getelementptr inbounds i8, i8* %35, i64 8
  %43 = bitcast i8* %42 to i64*
  %44 = load i64, i64* %43, align 8, !tbaa !11
  %45 = load i64*, i64** %39, align 8, !tbaa !2
  %46 = tail call zeroext i8 @UnlockSpinlock(i64* %45) #4
  %47 = icmp eq i64 %44, %id
  %48 = add i64 %i.09, 1
  br i1 %47, label %49, label %30

; <label>:49                                      ; preds = %get_thread_ID.exit4
  %.lcssa31 = phi i64** [ %39, %get_thread_ID.exit4 ]
  %.lcssa = phi i8* [ %35, %get_thread_ID.exit4 ]
  %50 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %51 = tail call zeroext i8 @LockSpinlock(i64* %50) #4
  %52 = getelementptr inbounds i8, i8* %.lcssa, i64 112
  %53 = bitcast i8* %52 to i32*
  %54 = load i32, i32* %53, align 4, !tbaa !43
  %55 = load i64*, i64** %.lcssa31, align 8, !tbaa !2
  %56 = tail call zeroext i8 @UnlockSpinlock(i64* %55) #4
  br label %.loopexit

.loopexit.loopexit:                               ; preds = %30
  br label %.loopexit

.loopexit:                                        ; preds = %.loopexit.loopexit, %.preheader, %49
  %.13 = phi i32 [ %54, %49 ], [ -1, %.preheader ], [ -1, %.loopexit.loopexit ]
  ret i32 %.13
}

; Function Attrs: noredzone nounwind uwtable
define void @FreeThread(i64 %id) #0 {
  tail call void @SetThreadState(i64 %id, i32 4) #5
  ret void
}

; Function Attrs: noredzone
declare void @RaiseInterrupt(i32) #2

; Function Attrs: noredzone nounwind uwtable
define %struct.ThreadInfo* @GetNextThread(%struct.ThreadInfo* %prevThread) #0 {
  %1 = icmp eq %struct.ThreadInfo* %prevThread, null
  br i1 %1, label %.lr.ph11.preheader, label %2

; <label>:2                                       ; preds = %0
  %3 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %4 = bitcast %struct.ThreadInfo* %prevThread to i8*
  %5 = tail call i32 @List_AddEntry(%struct.List* %3, i8* %4) #4
  br label %.lr.ph11.preheader

.lr.ph11.preheader:                               ; preds = %2, %0
  br label %.lr.ph11

.lr.ph11:                                         ; preds = %.lr.ph11.backedge, %.lr.ph11.preheader
  %6 = load i64*, i64** @sync_lock, align 8, !tbaa !56
  %7 = tail call zeroext i8 @LockSpinlock(i64* %6) #4
  %8 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %9 = tail call i8* @List_EntryAt(%struct.List* %8, i64 0) #4
  %10 = icmp eq i8* %9, null
  br i1 %10, label %.thread, label %get_thread_state.exit

.thread:                                          ; preds = %.lr.ph11
  %11 = load i64*, i64** @sync_lock, align 8, !tbaa !56
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  br label %.lr.ph11.backedge

get_thread_state.exit:                            ; preds = %.lr.ph11
  %13 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  tail call void @List_Remove(%struct.List* %13, i64 0) #4
  %14 = load i64*, i64** @sync_lock, align 8, !tbaa !56
  %15 = tail call zeroext i8 @UnlockSpinlock(i64* %14) #4
  %16 = getelementptr inbounds i8, i8* %9, i64 168
  %17 = bitcast i8* %16 to i64**
  %18 = load i64*, i64** %17, align 8, !tbaa !2
  %19 = tail call zeroext i8 @LockSpinlock(i64* %18) #4
  %20 = getelementptr inbounds i8, i8* %9, i64 32
  %21 = bitcast i8* %20 to i32*
  %22 = load i32, i32* %21, align 4, !tbaa !25
  %23 = load i64*, i64** %17, align 8, !tbaa !2
  %24 = tail call zeroext i8 @UnlockSpinlock(i64* %23) #4
  switch i32 %22, label %.outer._crit_edge.loopexit [
    i32 4, label %25
    i32 2, label %.lr.ph11.backedge
    i32 3, label %113
  ]

; <label>:25                                      ; preds = %get_thread_state.exit
  %26 = load i64*, i64** %17, align 8, !tbaa !2
  %27 = tail call i64 @GetSpinlockContenderCount(i64* %26) #4
  %28 = icmp eq i64 %27, 0
  br i1 %28, label %29, label %110

; <label>:29                                      ; preds = %25
  %30 = load i64*, i64** %17, align 8, !tbaa !2
  %31 = tail call zeroext i8 @LockSpinlock(i64* %30) #4
  %32 = getelementptr inbounds i8, i8* %9, i64 72
  %33 = bitcast i8* %32 to i64*
  %34 = load i64, i64* %33, align 8, !tbaa !37
  %35 = add i64 %34, -16384
  %36 = inttoptr i64 %35 to i8*
  tail call void @kfree(i8* %36) #4
  %37 = getelementptr inbounds i8, i8* %9, i64 64
  %38 = bitcast i8* %37 to i64*
  %39 = load i64, i64* %38, align 8, !tbaa !31
  %40 = add i64 %39, -16384
  %41 = inttoptr i64 %40 to i8*
  tail call void @kfree(i8* %41) #4
  %42 = getelementptr inbounds i8, i8* %9, i64 80
  %43 = bitcast i8* %42 to i64*
  %44 = load i64, i64* %43, align 8, !tbaa !35
  %45 = add i64 %44, -16256
  %46 = inttoptr i64 %45 to i8*
  %47 = tail call i8* @GetPhysicalAddress(i8* %46) #4
  %48 = ptrtoint i8* %47 to i64
  tail call void @FreePhysicalPageCont(i64 %48, i32 2) #4
  %49 = getelementptr inbounds i8, i8* %9, i64 16
  %50 = bitcast i8* %49 to %struct.ProcessInformation**
  %51 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %52 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %51, i64 0, i32 10
  %53 = load i64*, i64** %52, align 8, !tbaa !15
  %54 = tail call zeroext i8 @LockSpinlock(i64* %53) #4
  %55 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %56 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %55, i64 0, i32 6
  %57 = load i64, i64* %56, align 8, !tbaa !19
  %58 = load i64, i64* %43, align 8, !tbaa !35
  %59 = add i64 %58, -16256
  %60 = tail call i32 @UnmapPage(i64 %57, i64 %59, i64 16384) #4
  %61 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %62 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %61, i64 0, i32 8
  %63 = load %struct.List*, %struct.List** %62, align 8, !tbaa !62
  %64 = tail call i64 @List_Length(%struct.List* %63) #4
  %65 = icmp eq i64 %64, 0
  %66 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %67 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %66, i64 0, i32 8
  %68 = load %struct.List*, %struct.List** %67, align 8, !tbaa !62
  br i1 %65, label %._crit_edge, label %.lr.ph

.lr.ph:                                           ; preds = %29
  %69 = getelementptr inbounds i8, i8* %9, i64 8
  %70 = bitcast i8* %69 to i64*
  br label %86

._crit_edge.loopexit:                             ; preds = %96
  %.lcssa72 = phi %struct.List* [ %105, %96 ]
  br label %._crit_edge

._crit_edge:                                      ; preds = %._crit_edge.loopexit, %29
  %.lcssa = phi %struct.List* [ %68, %29 ], [ %.lcssa72, %._crit_edge.loopexit ]
  %71 = tail call i64 @List_Length(%struct.List* %.lcssa) #4
  %72 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %73 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %72, i64 0, i32 2
  %74 = load i32, i32* %73, align 4, !tbaa !64
  %75 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %72, i64 0, i32 0
  %76 = load i64, i64* %75, align 8, !tbaa !17
  %77 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %72, i64 0, i32 10
  %78 = load i64*, i64** %77, align 8, !tbaa !15
  %79 = tail call zeroext i8 @UnlockSpinlock(i64* %78) #4
  %80 = icmp eq i64 %71, 0
  %81 = zext i1 %80 to i32
  %82 = icmp eq i32 %74, 2
  %83 = zext i1 %82 to i32
  %84 = or i32 %83, %81
  %85 = icmp eq i32 %84, 0
  br i1 %85, label %108, label %106

; <label>:86                                      ; preds = %.lr.ph, %96
  %87 = phi %struct.List* [ %68, %.lr.ph ], [ %105, %96 ]
  %i.010 = phi i64 [ 0, %.lr.ph ], [ %97, %96 ]
  %88 = tail call i8* @List_EntryAt(%struct.List* %87, i64 %i.010) #4
  %89 = ptrtoint i8* %88 to i64
  %90 = load i64, i64* %70, align 8, !tbaa !11
  %91 = icmp eq i64 %89, %90
  br i1 %91, label %92, label %96

; <label>:92                                      ; preds = %86
  %93 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %94 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %93, i64 0, i32 8
  %95 = load %struct.List*, %struct.List** %94, align 8, !tbaa !62
  tail call void @List_Remove(%struct.List* %95, i64 %i.010) #4
  br label %96

; <label>:96                                      ; preds = %86, %92
  %97 = add i64 %i.010, 1
  %98 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %99 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %98, i64 0, i32 8
  %100 = load %struct.List*, %struct.List** %99, align 8, !tbaa !62
  %101 = tail call i64 @List_Length(%struct.List* %100) #4
  %102 = icmp ult i64 %97, %101
  %103 = load %struct.ProcessInformation*, %struct.ProcessInformation** %50, align 8, !tbaa !13
  %104 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %103, i64 0, i32 8
  %105 = load %struct.List*, %struct.List** %104, align 8, !tbaa !62
  br i1 %102, label %86, label %._crit_edge.loopexit

; <label>:106                                     ; preds = %._crit_edge
  %107 = tail call i32 @KillProcess(i64 %76) #4
  br label %108

; <label>:108                                     ; preds = %._crit_edge, %106
  %109 = load i64*, i64** %17, align 8, !tbaa !2
  tail call void @FreeSpinlock(i64* %109) #4
  tail call void @kfree(i8* %9) #4
  br label %.lr.ph11.backedge

.lr.ph11.backedge:                                ; preds = %108, %110, %get_thread_state.exit, %.thread, %134, %139
  br label %.lr.ph11

; <label>:110                                     ; preds = %25
  %111 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %112 = tail call i32 @List_AddEntry(%struct.List* %111, i8* %9) #4
  br label %.lr.ph11.backedge

; <label>:113                                     ; preds = %get_thread_state.exit
  %114 = load i64*, i64** %17, align 8, !tbaa !2
  %115 = tail call zeroext i8 @LockSpinlock(i64* %114) #4
  %116 = tail call i64 @GetTimerValue() #4
  %117 = getelementptr inbounds i8, i8* %9, i64 36
  %118 = bitcast i8* %117 to i32*
  %119 = load i32, i32* %118, align 4, !tbaa !27
  %120 = icmp eq i32 %119, 1
  br i1 %120, label %121, label %139

; <label>:121                                     ; preds = %113
  %122 = getelementptr inbounds i8, i8* %9, i64 128
  %123 = bitcast i8* %122 to i64*
  %124 = load i64, i64* %123, align 8, !tbaa !47
  %125 = sub i64 %116, %124
  %126 = tail call i64 @GetTimerInterval_NS(i64 %125) #4
  %127 = getelementptr inbounds i8, i8* %9, i64 120
  %128 = bitcast i8* %127 to i64*
  %129 = load i64, i64* %128, align 8, !tbaa !45
  %130 = icmp ult i64 %126, %129
  br i1 %130, label %134, label %131

; <label>:131                                     ; preds = %121
  %.lcssa78 = phi i32* [ %21, %121 ]
  %.lcssa76 = phi i64** [ %17, %121 ]
  %.lcssa74 = phi i8* [ %9, %121 ]
  store i32 1, i32* %.lcssa78, align 4, !tbaa !25
  %132 = load i64*, i64** %.lcssa76, align 8, !tbaa !2
  %133 = tail call zeroext i8 @UnlockSpinlock(i64* %132) #4
  br label %.outer._crit_edge

; <label>:134                                     ; preds = %121
  %135 = load i64*, i64** %17, align 8, !tbaa !2
  %136 = tail call zeroext i8 @UnlockSpinlock(i64* %135) #4
  %137 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %138 = tail call i32 @List_AddEntry(%struct.List* %137, i8* %9) #4
  br label %.lr.ph11.backedge

; <label>:139                                     ; preds = %113
  %140 = load i64*, i64** %17, align 8, !tbaa !2
  %141 = tail call zeroext i8 @UnlockSpinlock(i64* %140) #4
  %142 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %143 = tail call i32 @List_AddEntry(%struct.List* %142, i8* %9) #4
  br label %.lr.ph11.backedge

.outer._crit_edge.loopexit:                       ; preds = %get_thread_state.exit
  %.lcssa73 = phi i8* [ %9, %get_thread_state.exit ]
  br label %.outer._crit_edge

.outer._crit_edge:                                ; preds = %.outer._crit_edge.loopexit, %131
  %144 = phi i8* [ %.lcssa73, %.outer._crit_edge.loopexit ], [ %.lcssa74, %131 ]
  %145 = bitcast i8* %144 to %struct.ThreadInfo*
  ret %struct.ThreadInfo* %145
}

; Function Attrs: noredzone
declare void @List_Remove(%struct.List*, i64) #2

; Function Attrs: noredzone
declare i64 @GetSpinlockContenderCount(i64*) #2

; Function Attrs: noredzone
declare void @FreePhysicalPageCont(i64, i32) #2

; Function Attrs: noredzone
declare i8* @GetPhysicalAddress(i8*) #2

; Function Attrs: noredzone
declare i32 @UnmapPage(i64, i64, i64) #2

; Function Attrs: noredzone
declare i32 @KillProcess(i64) #2

; Function Attrs: noredzone
declare i64 @GetTimerInterval_NS(i64) #2

; Function Attrs: noredzone nounwind uwtable
define void @TaskSwitch(i32 %int_no, i32 %err_code) #0 {
  %1 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %2 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %1, i64 0, i32 0
  %3 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %2, align 8, !tbaa !57
  %4 = icmp eq %struct.ThreadInfo* %3, null
  br i1 %4, label %5, label %get_thread_fpu_state.exit

; <label>:5                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !50
  br label %get_thread_fpu_state.exit

get_thread_fpu_state.exit:                        ; preds = %0, %5
  %6 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 22
  %7 = load i64*, i64** %6, align 8, !tbaa !2
  %8 = tail call zeroext i8 @LockSpinlock(i64* %7) #4
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %3, i64 0, i32 20
  %10 = load i8*, i8** %9, align 8, !tbaa !51
  %11 = load i64*, i64** %6, align 8, !tbaa !2
  %12 = tail call zeroext i8 @UnlockSpinlock(i64* %11) #4
  tail call void @SaveFPUState(i8* %10) #4
  %13 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %14 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %13, i64 0, i32 0
  %15 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %14, align 8, !tbaa !57
  tail call void @PerformArchSpecificTaskSave(%struct.ThreadInfo* %15) #4
  %16 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %17 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %16, i64 0, i32 0
  %18 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %17, align 8, !tbaa !57
  tail call void @SavePreviousThread(%struct.ThreadInfo* %18) #4
  %19 = load %struct.List*, %struct.List** @thds, align 8, !tbaa !56
  %20 = tail call i64 @List_Length(%struct.List* %19) #4
  %21 = icmp eq i64 %20, 0
  br i1 %21, label %29, label %22

; <label>:22                                      ; preds = %get_thread_fpu_state.exit
  %23 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %24 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %23, i64 0, i32 0
  %25 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %24, align 8, !tbaa !57
  %26 = tail call %struct.ThreadInfo* @GetNextThread(%struct.ThreadInfo* %25) #5
  %27 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %28 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %27, i64 0, i32 0
  store volatile %struct.ThreadInfo* %26, %struct.ThreadInfo** %28, align 8, !tbaa !57
  br label %29

; <label>:29                                      ; preds = %get_thread_fpu_state.exit, %22
  %30 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %31 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %30, i64 0, i32 0
  %32 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %31, align 8, !tbaa !57
  %33 = icmp eq %struct.ThreadInfo* %32, null
  br i1 %33, label %34, label %get_thread_fpu_state.exit1

; <label>:34                                      ; preds = %29
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !50
  br label %get_thread_fpu_state.exit1

get_thread_fpu_state.exit1:                       ; preds = %29, %34
  %35 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %32, i64 0, i32 22
  %36 = load i64*, i64** %35, align 8, !tbaa !2
  %37 = tail call zeroext i8 @LockSpinlock(i64* %36) #4
  %38 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %32, i64 0, i32 20
  %39 = load i8*, i8** %38, align 8, !tbaa !51
  %40 = load i64*, i64** %35, align 8, !tbaa !2
  %41 = tail call zeroext i8 @UnlockSpinlock(i64* %40) #4
  tail call void @RestoreFPUState(i8* %39) #4
  %42 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %43 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %42, i64 0, i32 0
  %44 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %43, align 8, !tbaa !57
  %45 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %44, i64 0, i32 14
  %46 = bitcast i64* %45 to i8**
  %47 = load i8*, i8** %46, align 8, !tbaa !33
  tail call void @SetInterruptStack(i8* %47) #4
  %48 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %49 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %48, i64 0, i32 0
  %50 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %49, align 8, !tbaa !57
  %51 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %50, i64 0, i32 13
  %52 = bitcast i64* %51 to i8**
  %53 = load i8*, i8** %52, align 8, !tbaa !39
  tail call void @SetKernelStack(i8* %53) #4
  %54 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %55 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %54, i64 0, i32 0
  %56 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %55, align 8, !tbaa !57
  %57 = icmp eq %struct.ThreadInfo* %56, null
  br i1 %57, label %58, label %get_thread_ParentProcess.exit

; <label>:58                                      ; preds = %get_thread_fpu_state.exit1
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !12
  br label %get_thread_ParentProcess.exit

get_thread_ParentProcess.exit:                    ; preds = %get_thread_fpu_state.exit1, %58
  %59 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %56, i64 0, i32 22
  %60 = load i64*, i64** %59, align 8, !tbaa !2
  %61 = tail call zeroext i8 @LockSpinlock(i64* %60) #4
  %62 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %56, i64 0, i32 2
  %63 = load %struct.ProcessInformation*, %struct.ProcessInformation** %62, align 8, !tbaa !13
  %64 = load i64*, i64** %59, align 8, !tbaa !2
  %65 = tail call zeroext i8 @UnlockSpinlock(i64* %64) #4
  %66 = icmp eq %struct.ProcessInformation* %63, null
  br i1 %66, label %67, label %get_proc_PageTable.exit

; <label>:67                                      ; preds = %get_thread_ParentProcess.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !18
  br label %get_proc_PageTable.exit

get_proc_PageTable.exit:                          ; preds = %get_thread_ParentProcess.exit, %67
  %68 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %63, i64 0, i32 10
  %69 = load i64*, i64** %68, align 8, !tbaa !15
  %70 = tail call zeroext i8 @LockSpinlock(i64* %69) #4
  %71 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %63, i64 0, i32 6
  %72 = load i64, i64* %71, align 8, !tbaa !19
  %73 = load i64*, i64** %68, align 8, !tbaa !15
  %74 = tail call zeroext i8 @UnlockSpinlock(i64* %73) #4
  %75 = tail call i64 @SetActiveVirtualMemoryInstance(i64 %72) #4
  %76 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %77 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %76, i64 0, i32 0
  %78 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %77, align 8, !tbaa !57
  tail call void @PerformArchSpecificTaskSwitch(%struct.ThreadInfo* %78) #4
  %79 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %80 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %79, i64 0, i32 0
  %81 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %80, align 8, !tbaa !57
  %82 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %81, i64 0, i32 4
  %83 = load i32, i32* %82, align 4, !tbaa !25
  %84 = icmp eq i32 %83, 1
  br i1 %84, label %85, label %89

; <label>:85                                      ; preds = %get_proc_PageTable.exit
  tail call void @HandleInterruptNoReturn(i32 %int_no) #4
  %86 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %87 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %86, i64 0, i32 0
  %88 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %87, align 8, !tbaa !57
  tail call void @SwitchToThread(%struct.ThreadInfo* %88) #4
  br label %102

; <label>:89                                      ; preds = %get_proc_PageTable.exit
  %90 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %80, align 8, !tbaa !57
  %91 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %90, i64 0, i32 4
  %92 = load i32, i32* %91, align 4, !tbaa !25
  %93 = icmp eq i32 %92, 0
  %94 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %80, align 8, !tbaa !57
  %95 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %94, i64 0, i32 4
  br i1 %93, label %96, label %100

; <label>:96                                      ; preds = %89
  store i32 1, i32* %95, align 4, !tbaa !25
  tail call void @HandleInterruptNoReturn(i32 %int_no) #4
  %97 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %98 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %97, i64 0, i32 0
  %99 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %98, align 8, !tbaa !57
  tail call void @SwitchAndInitializeThread(%struct.ThreadInfo* %99) #4
  br label %102

; <label>:100                                     ; preds = %89
  %101 = load i32, i32* %95, align 4, !tbaa !25
  tail call void asm sideeffect "cli\0A\09hlt", "{ax},~{dirflag},~{fpsr},~{flags}"(i32 %101) #1, !srcloc !65
  br label %102

; <label>:102                                     ; preds = %96, %100, %85
  ret void
}

; Function Attrs: noredzone
declare void @PerformArchSpecificTaskSave(%struct.ThreadInfo*) #2

; Function Attrs: noredzone
declare void @SavePreviousThread(%struct.ThreadInfo*) #2

; Function Attrs: noredzone
declare void @RestoreFPUState(i8*) #2

; Function Attrs: noredzone
declare void @SetInterruptStack(i8*) #2

; Function Attrs: noredzone
declare void @SetKernelStack(i8*) #2

; Function Attrs: noredzone
declare i64 @SetActiveVirtualMemoryInstance(i64) #2

; Function Attrs: noredzone
declare void @PerformArchSpecificTaskSwitch(%struct.ThreadInfo*) #2

; Function Attrs: noredzone
declare void @HandleInterruptNoReturn(i32) #2

; Function Attrs: noredzone
declare void @SwitchToThread(%struct.ThreadInfo*) #2

; Function Attrs: noredzone
declare void @SwitchAndInitializeThread(%struct.ThreadInfo*) #2

; Function Attrs: noredzone nounwind uwtable
define void @SetPeriodicPreemptVector(i32 %irq, i64 %frequency) #0 {
  %1 = tail call i32 @RegisterInterruptHandler(i32 %irq, void (i32, i32)* nonnull @TaskSwitch) #4
  store i32 %irq, i32* @preempt_vector, align 4, !tbaa !63
  ret void
}

; Function Attrs: noredzone
declare i32 @RegisterInterruptHandler(i32, void (i32, i32)*) #2

; Function Attrs: noredzone nounwind uwtable
define void @SwitchThread() #0 {
  %1 = tail call %struct.ThreadInfo* @GetNextThread(%struct.ThreadInfo* null) #5
  %2 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %3 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %2, i64 0, i32 0
  store volatile %struct.ThreadInfo* %1, %struct.ThreadInfo** %3, align 8, !tbaa !57
  %4 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %5 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %4, i64 0, i32 0
  %6 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %5, align 8, !tbaa !57
  %7 = icmp eq %struct.ThreadInfo* %6, null
  br i1 %7, label %8, label %get_thread_fpu_state.exit

; <label>:8                                       ; preds = %0
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !50
  br label %get_thread_fpu_state.exit

get_thread_fpu_state.exit:                        ; preds = %0, %8
  %9 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %6, i64 0, i32 22
  %10 = load i64*, i64** %9, align 8, !tbaa !2
  %11 = tail call zeroext i8 @LockSpinlock(i64* %10) #4
  %12 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %6, i64 0, i32 20
  %13 = load i8*, i8** %12, align 8, !tbaa !51
  %14 = load i64*, i64** %9, align 8, !tbaa !2
  %15 = tail call zeroext i8 @UnlockSpinlock(i64* %14) #4
  tail call void @RestoreFPUState(i8* %13) #4
  %16 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %17 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %16, i64 0, i32 0
  %18 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %17, align 8, !tbaa !57
  %19 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %18, i64 0, i32 14
  %20 = bitcast i64* %19 to i8**
  %21 = load i8*, i8** %20, align 8, !tbaa !33
  tail call void @SetInterruptStack(i8* %21) #4
  %22 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %23 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %22, i64 0, i32 0
  %24 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %23, align 8, !tbaa !57
  %25 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %24, i64 0, i32 13
  %26 = bitcast i64* %25 to i8**
  %27 = load i8*, i8** %26, align 8, !tbaa !39
  tail call void @SetKernelStack(i8* %27) #4
  %28 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %29 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %28, i64 0, i32 0
  %30 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %29, align 8, !tbaa !57
  %31 = icmp eq %struct.ThreadInfo* %30, null
  br i1 %31, label %32, label %get_thread_ParentProcess.exit

; <label>:32                                      ; preds = %get_thread_fpu_state.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !12
  br label %get_thread_ParentProcess.exit

get_thread_ParentProcess.exit:                    ; preds = %get_thread_fpu_state.exit, %32
  %33 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %30, i64 0, i32 22
  %34 = load i64*, i64** %33, align 8, !tbaa !2
  %35 = tail call zeroext i8 @LockSpinlock(i64* %34) #4
  %36 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %30, i64 0, i32 2
  %37 = load %struct.ProcessInformation*, %struct.ProcessInformation** %36, align 8, !tbaa !13
  %38 = load i64*, i64** %33, align 8, !tbaa !2
  %39 = tail call zeroext i8 @UnlockSpinlock(i64* %38) #4
  %40 = icmp eq %struct.ProcessInformation* %37, null
  br i1 %40, label %41, label %get_proc_PageTable.exit

; <label>:41                                      ; preds = %get_thread_ParentProcess.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !18
  br label %get_proc_PageTable.exit

get_proc_PageTable.exit:                          ; preds = %get_thread_ParentProcess.exit, %41
  %42 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %37, i64 0, i32 10
  %43 = load i64*, i64** %42, align 8, !tbaa !15
  %44 = tail call zeroext i8 @LockSpinlock(i64* %43) #4
  %45 = getelementptr inbounds %struct.ProcessInformation, %struct.ProcessInformation* %37, i64 0, i32 6
  %46 = load i64, i64* %45, align 8, !tbaa !19
  %47 = load i64*, i64** %42, align 8, !tbaa !15
  %48 = tail call zeroext i8 @UnlockSpinlock(i64* %47) #4
  %49 = tail call i64 @SetActiveVirtualMemoryInstance(i64 %46) #4
  %50 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %51 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %50, i64 0, i32 0
  %52 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %51, align 8, !tbaa !57
  tail call void @PerformArchSpecificTaskSwitch(%struct.ThreadInfo* %52) #4
  %53 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %54 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %53, i64 0, i32 0
  %55 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %54, align 8, !tbaa !57
  %56 = icmp eq %struct.ThreadInfo* %55, null
  br i1 %56, label %57, label %get_thread_state.exit

; <label>:57                                      ; preds = %get_proc_PageTable.exit
  tail call void asm sideeffect "add $$0x20, %rsp\0A\09popq %rax\0A\09popq %rax\0A\09cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !24
  br label %get_thread_state.exit

get_thread_state.exit:                            ; preds = %get_proc_PageTable.exit, %57
  %58 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %55, i64 0, i32 22
  %59 = load i64*, i64** %58, align 8, !tbaa !2
  %60 = tail call zeroext i8 @LockSpinlock(i64* %59) #4
  %61 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %55, i64 0, i32 4
  %62 = load i32, i32* %61, align 4, !tbaa !25
  %63 = load i64*, i64** %58, align 8, !tbaa !2
  %64 = tail call zeroext i8 @UnlockSpinlock(i64* %63) #4
  %65 = icmp eq i32 %62, 0
  br i1 %65, label %66, label %79

; <label>:66                                      ; preds = %get_thread_state.exit
  %67 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %68 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %67, i64 0, i32 0
  %69 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %68, align 8, !tbaa !57
  %70 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %69, i64 0, i32 22
  %71 = load i64*, i64** %70, align 8, !tbaa !2
  %72 = tail call zeroext i8 @LockSpinlock(i64* %71) #4
  %73 = getelementptr inbounds %struct.ThreadInfo, %struct.ThreadInfo* %69, i64 0, i32 4
  store i32 1, i32* %73, align 4, !tbaa !25
  %74 = load i64*, i64** %70, align 8, !tbaa !2
  %75 = tail call zeroext i8 @UnlockSpinlock(i64* %74) #4
  %76 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %77 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %76, i64 0, i32 0
  %78 = load volatile %struct.ThreadInfo*, %struct.ThreadInfo** %77, align 8, !tbaa !57
  tail call void @SwitchAndInitializeThread(%struct.ThreadInfo* %78) #4
  br label %79

; <label>:79                                      ; preds = %66, %get_thread_state.exit
  tail call void asm sideeffect "cli\0A\09hlt", "~{dirflag},~{fpsr},~{flags}"() #1, !srcloc !66
  ret void
}

; Function Attrs: noredzone noreturn nounwind uwtable
define void @CoreUpdate() #3 {
  br label %1

; <label>:1                                       ; preds = %0, %1
  tail call void @SwitchThread() #5
  br label %1
}

; Function Attrs: noredzone nounwind uwtable
define void @RegisterCore(i32 %id, i32 ()* %getCoreData) #0 {
  %1 = tail call i8* @kmalloc(i64 16) #4
  %2 = sext i32 %id to i64
  %3 = bitcast i8* %1 to i64*
  store i64 %2, i64* %3, align 8, !tbaa !67
  %4 = getelementptr inbounds i8, i8* %1, i64 8
  %5 = bitcast i8* %4 to i32 ()**
  store i32 ()* %getCoreData, i32 ()** %5, align 8, !tbaa !69
  %6 = load %struct.List*, %struct.List** @cores, align 8, !tbaa !56
  %7 = tail call i32 @List_AddEntry(%struct.List* %6, i8* %1) #4
  %8 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %9 = icmp eq %struct.CoreThreadState* %8, null
  br i1 %9, label %10, label %13

; <label>:10                                      ; preds = %0
  %11 = tail call i8* @AllocateAPLSMemory(i64 16) #4
  store i8* %11, i8** bitcast (%struct.CoreThreadState** @coreState to i8**), align 8, !tbaa !56
  %12 = bitcast i8* %11 to %struct.CoreThreadState*
  br label %13

; <label>:13                                      ; preds = %10, %0
  %14 = phi %struct.CoreThreadState* [ %12, %10 ], [ %8, %0 ]
  %15 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %14, i64 0, i32 0
  store volatile %struct.ThreadInfo* null, %struct.ThreadInfo** %15, align 8, !tbaa !57
  %16 = load %struct.CoreThreadState*, %struct.CoreThreadState** @coreState, align 8, !tbaa !56
  %17 = getelementptr inbounds %struct.CoreThreadState, %struct.CoreThreadState* %16, i64 0, i32 1
  store volatile i32 %id, i32* %17, align 4, !tbaa !70
  ret void
}

; Function Attrs: noredzone
declare i8* @AllocateAPLSMemory(i64) #2

; Function Attrs: noredzone nounwind uwtable
define i32 @GetCoreLoad(i32 %coreNum) #0 {
  %1 = load %struct.List*, %struct.List** @cores, align 8, !tbaa !56
  %2 = tail call i64 @List_Length(%struct.List* %1) #4
  %3 = trunc i64 %2 to i32
  %4 = icmp slt i32 %3, %coreNum
  br i1 %4, label %13, label %5

; <label>:5                                       ; preds = %0
  %6 = load %struct.List*, %struct.List** @cores, align 8, !tbaa !56
  %7 = sext i32 %coreNum to i64
  %8 = tail call i8* @List_EntryAt(%struct.List* %6, i64 %7) #4
  %9 = getelementptr inbounds i8, i8* %8, i64 8
  %10 = bitcast i8* %9 to i32 ()**
  %11 = load i32 ()*, i32 ()** %10, align 8, !tbaa !69
  %12 = tail call i32 %11() #4
  br label %13

; <label>:13                                      ; preds = %0, %5
  %.0 = phi i32 [ %12, %5 ], [ -1, %0 ]
  ret i32 %.0
}

attributes #0 = { noredzone nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind }
attributes #2 = { noredzone "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noredzone noreturn nounwind uwtable "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="-3dnow,-3dnowa,-aes,-avx,-avx2,-avx512bw,-avx512cd,-avx512dq,-avx512er,-avx512f,-avx512pf,-avx512vl,-f16c,-fma,-fma4,-pclmul,-sha,-sse,-sse2,-sse3,-sse4.1,-sse4.2,-sse4a,-ssse3,-xop" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nobuiltin noredzone nounwind }
attributes #5 = { nobuiltin noredzone }

!llvm.ident = !{!0}

!0 = !{!"clang version 3.7.0 (tags/RELEASE_370/final)"}
!1 = !{i32 -2147395212, i32 -2147395194, i32 -2147395181, i32 -2147395168, i32 -2147395161}
!2 = !{!3, !7, i64 168}
!3 = !{!"ThreadInfo", !4, i64 0, !4, i64 8, !7, i64 16, !7, i64 24, !5, i64 32, !5, i64 36, !5, i64 40, !4, i64 48, !4, i64 56, !4, i64 64, !4, i64 72, !4, i64 80, !4, i64 88, !4, i64 96, !4, i64 104, !8, i64 112, !4, i64 120, !4, i64 128, !7, i64 136, !7, i64 144, !7, i64 152, !7, i64 160, !7, i64 168}
!4 = !{!"long", !5, i64 0}
!5 = !{!"omnipotent char", !6, i64 0}
!6 = !{!"Simple C/C++ TBAA"}
!7 = !{!"any pointer", !5, i64 0}
!8 = !{!"int", !5, i64 0}
!9 = !{!3, !4, i64 0}
!10 = !{i32 -2147394243, i32 -2147394225, i32 -2147394212, i32 -2147394199, i32 -2147394192}
!11 = !{!3, !4, i64 8}
!12 = !{i32 -2147393224, i32 -2147393206, i32 -2147393193, i32 -2147393180, i32 -2147393173}
!13 = !{!3, !7, i64 16}
!14 = !{i32 -2147392259, i32 -2147392241, i32 -2147392228, i32 -2147392215, i32 -2147392208}
!15 = !{!16, !7, i64 488}
!16 = !{!"ProcessInformation", !4, i64 0, !5, i64 8, !5, i64 264, !5, i64 268, !5, i64 272, !5, i64 280, !4, i64 456, !7, i64 464, !7, i64 472, !5, i64 480, !7, i64 488}
!17 = !{!16, !4, i64 0}
!18 = !{i32 -2147391718, i32 -2147391700, i32 -2147391687, i32 -2147391674, i32 -2147391667}
!19 = !{!16, !4, i64 456}
!20 = !{i32 -2147391156, i32 -2147391138, i32 -2147391125, i32 -2147391112, i32 -2147391105}
!21 = !{!16, !7, i64 464}
!22 = !{i32 -2147390359, i32 -2147390341, i32 -2147390328, i32 -2147390315, i32 -2147390308}
!23 = !{!3, !7, i64 24}
!24 = !{i32 -2147389290, i32 -2147389272, i32 -2147389259, i32 -2147389246, i32 -2147389239}
!25 = !{!3, !5, i64 32}
!26 = !{i32 -2147388249, i32 -2147388231, i32 -2147388218, i32 -2147388205, i32 -2147388198}
!27 = !{!3, !5, i64 36}
!28 = !{i32 -2147387156, i32 -2147387138, i32 -2147387125, i32 -2147387112, i32 -2147387105}
!29 = !{!3, !5, i64 40}
!30 = !{i32 -2147386096, i32 -2147386078, i32 -2147386065, i32 -2147386052, i32 -2147386045}
!31 = !{!3, !4, i64 64}
!32 = !{i32 -2147384976, i32 -2147384958, i32 -2147384945, i32 -2147384932, i32 -2147384925}
!33 = !{!3, !4, i64 104}
!34 = !{i32 -2147383854, i32 -2147383836, i32 -2147383823, i32 -2147383810, i32 -2147383803}
!35 = !{!3, !4, i64 80}
!36 = !{i32 -2147382776, i32 -2147382758, i32 -2147382745, i32 -2147382732, i32 -2147382725}
!37 = !{!3, !4, i64 72}
!38 = !{i32 -2147381680, i32 -2147381662, i32 -2147381649, i32 -2147381636, i32 -2147381629}
!39 = !{!3, !4, i64 96}
!40 = !{i32 -2147380580, i32 -2147380562, i32 -2147380549, i32 -2147380536, i32 -2147380529}
!41 = !{!3, !4, i64 88}
!42 = !{i32 -2147379532, i32 -2147379514, i32 -2147379501, i32 -2147379488, i32 -2147379481}
!43 = !{!3, !8, i64 112}
!44 = !{i32 -2147378481, i32 -2147378463, i32 -2147378450, i32 -2147378437, i32 -2147378430}
!45 = !{!3, !4, i64 120}
!46 = !{i32 -2147377393, i32 -2147377375, i32 -2147377362, i32 -2147377349, i32 -2147377342}
!47 = !{!3, !4, i64 128}
!48 = !{i32 -2147376293, i32 -2147376275, i32 -2147376262, i32 -2147376249, i32 -2147376242}
!49 = !{!3, !7, i64 160}
!50 = !{i32 -2147375199, i32 -2147375181, i32 -2147375168, i32 -2147375155, i32 -2147375148}
!51 = !{!3, !7, i64 152}
!52 = !{i32 -2147374151, i32 -2147374133, i32 -2147374120, i32 -2147374107, i32 -2147374100}
!53 = !{!3, !7, i64 136}
!54 = !{i32 -2147373075, i32 -2147373057, i32 -2147373044, i32 -2147373031, i32 -2147373024}
!55 = !{!3, !7, i64 144}
!56 = !{!7, !7, i64 0}
!57 = !{!58, !7, i64 0}
!58 = !{!"CoreThreadState", !7, i64 0, !8, i64 8}
!59 = !{!4, !4, i64 0}
!60 = !{!61, !7, i64 56}
!61 = !{!"MemoryAllocationsMap", !5, i64 0, !4, i64 8, !4, i64 16, !4, i64 24, !5, i64 32, !5, i64 36, !4, i64 40, !4, i64 48, !7, i64 56}
!62 = !{!16, !7, i64 472}
!63 = !{!8, !8, i64 0}
!64 = !{!16, !5, i64 264}
!65 = !{i32 18261, i32 18267}
!66 = !{i32 19252, i32 19258}
!67 = !{!68, !4, i64 0}
!68 = !{!"CoreInfo", !4, i64 0, !7, i64 8}
!69 = !{!68, !7, i64 8}
!70 = !{!58, !8, i64 8}
